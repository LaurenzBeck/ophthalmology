
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../../../docs/images/retina.jpg">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.3.0">
    
    
      
        <title>Simclr - ophthalmology</title>
      
    
    
      <link rel="stylesheet" href="../../../../assets/stylesheets/main.8b42a75e.min.css">
      
        
        <link rel="stylesheet" href="../../../../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("../../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#module-ophthalmologymodulessimclr" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../../.." title="ophthalmology" class="md-header__button md-logo" aria-label="ophthalmology" data-md-component="logo">
      
  <img src="../../../../docs/images/retina.jpg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            ophthalmology
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Simclr
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        
<a href="https://github.com/LaurenzBeck/ophthalmology/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    ophthalmology
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../../.." title="ophthalmology" class="md-nav__button md-logo" aria-label="ophthalmology" data-md-component="logo">
      
  <img src="../../../../docs/images/retina.jpg" alt="logo">

    </a>
    ophthalmology
  </label>
  
    <div class="md-nav__source">
      
<a href="https://github.com/LaurenzBeck/ophthalmology/" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    ophthalmology
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/datasets/" class="md-nav__link">
        Datasets
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../../docs/experiments/" class="md-nav__link">
        Experiments
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4" type="checkbox" id="__nav_4" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_4">
          Reference
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Reference" data-md-level="1">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          Reference
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1" type="checkbox" id="__nav_4_1" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1">
          Ophthalmology
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Ophthalmology" data-md-level="2">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          Ophthalmology
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../visualization/" class="md-nav__link">
        Visualization
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1_3" type="checkbox" id="__nav_4_1_3" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1_3">
          Data
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Data" data-md-level="3">
        <label class="md-nav__title" for="__nav_4_1_3">
          <span class="md-nav__icon md-icon"></span>
          Data
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../data/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../data/modules/" class="md-nav__link">
        Modules
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../data/sets/" class="md-nav__link">
        Sets
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1_4" type="checkbox" id="__nav_4_1_4" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1_4">
          Layers
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Layers" data-md-level="3">
        <label class="md-nav__title" for="__nav_4_1_4">
          <span class="md-nav__icon md-icon"></span>
          Layers
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/activations/" class="md-nav__link">
        Activations
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/assp/" class="md-nav__link">
        Assp
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/convolutional_stems/" class="md-nav__link">
        Convolutional Stems
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/heads/" class="md-nav__link">
        Heads
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/involution/" class="md-nav__link">
        Involution
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/noise/" class="md-nav__link">
        Noise
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/residual_blocks/" class="md-nav__link">
        Residual Blocks
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../layers/squeeze_and_excitation/" class="md-nav__link">
        Squeeze And Excitation
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1_5" type="checkbox" id="__nav_4_1_5" >
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1_5">
          Models
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Models" data-md-level="3">
        <label class="md-nav__title" for="__nav_4_1_5">
          <span class="md-nav__icon md-icon"></span>
          Models
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../models/attentive_nf_resnet/" class="md-nav__link">
        Attentive Nf Resnet
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../models/" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../models/resnet/" class="md-nav__link">
        Resnet
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_4_1_6" type="checkbox" id="__nav_4_1_6" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_4_1_6">
          Modules
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Modules" data-md-level="3">
        <label class="md-nav__title" for="__nav_4_1_6">
          <span class="md-nav__icon md-icon"></span>
          Modules
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../disease_grading/" class="md-nav__link">
        Disease Grading
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        Index
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Simclr
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Simclr
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#contrastive-representation-learning-task" class="md-nav__link">
    Contrastive representation learning task
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ntxentloss" class="md-nav__link">
    NTXentLoss
  </a>
  
    <nav class="md-nav" aria-label="NTXentLoss">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#add_module" class="md-nav__link">
    add_module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apply" class="md-nav__link">
    apply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfloat16" class="md-nav__link">
    bfloat16
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffers" class="md-nav__link">
    buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children" class="md-nav__link">
    children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cpu" class="md-nav__link">
    cpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cuda" class="md-nav__link">
    cuda
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double" class="md-nav__link">
    double
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eval" class="md-nav__link">
    eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extra_repr" class="md-nav__link">
    extra_repr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#float" class="md-nav__link">
    float
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forward" class="md-nav__link">
    forward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_buffer" class="md-nav__link">
    get_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_extra_state" class="md-nav__link">
    get_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_parameter" class="md-nav__link">
    get_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submodule" class="md-nav__link">
    get_submodule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#half" class="md-nav__link">
    half
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load_state_dict" class="md-nav__link">
    load_state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modules" class="md-nav__link">
    modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_buffers" class="md-nav__link">
    named_buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_children" class="md-nav__link">
    named_children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_modules" class="md-nav__link">
    named_modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_parameters" class="md-nav__link">
    named_parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_backward_hook" class="md-nav__link">
    register_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_buffer" class="md-nav__link">
    register_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_hook" class="md-nav__link">
    register_forward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_pre_hook" class="md-nav__link">
    register_forward_pre_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_full_backward_hook" class="md-nav__link">
    register_full_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_parameter" class="md-nav__link">
    register_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requires_grad_" class="md-nav__link">
    requires_grad_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_extra_state" class="md-nav__link">
    set_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#share_memory" class="md-nav__link">
    share_memory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#state_dict" class="md-nav__link">
    state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to" class="md-nav__link">
    to
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_empty" class="md-nav__link">
    to_empty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train" class="md-nav__link">
    train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type" class="md-nav__link">
    type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xpu" class="md-nav__link">
    xpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zero_grad" class="md-nav__link">
    zero_grad
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#simclr" class="md-nav__link">
    SimCLR
  </a>
  
    <nav class="md-nav" aria-label="SimCLR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_1" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables_1" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-methods" class="md-nav__link">
    Static methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load_from_checkpoint" class="md-nav__link">
    load_from_checkpoint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_1" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#add_module_1" class="md-nav__link">
    add_module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#add_to_queue" class="md-nav__link">
    add_to_queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all_gather" class="md-nav__link">
    all_gather
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apply_1" class="md-nav__link">
    apply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#backward" class="md-nav__link">
    backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfloat16_1" class="md-nav__link">
    bfloat16
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffers_1" class="md-nav__link">
    buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children_1" class="md-nav__link">
    children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clip_gradients" class="md-nav__link">
    clip_gradients
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_callbacks" class="md-nav__link">
    configure_callbacks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_gradient_clipping" class="md-nav__link">
    configure_gradient_clipping
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_optimizers" class="md-nav__link">
    configure_optimizers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_sharded_model" class="md-nav__link">
    configure_sharded_model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cpu_1" class="md-nav__link">
    cpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cuda_1" class="md-nav__link">
    cuda
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double_1" class="md-nav__link">
    double
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eval_1" class="md-nav__link">
    eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exclude_from_wt_decay" class="md-nav__link">
    exclude_from_wt_decay
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extra_repr_1" class="md-nav__link">
    extra_repr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#float_1" class="md-nav__link">
    float
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forward_1" class="md-nav__link">
    forward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#freeze" class="md-nav__link">
    freeze
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_buffer_1" class="md-nav__link">
    get_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_extra_state_1" class="md-nav__link">
    get_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_from_queue" class="md-nav__link">
    get_from_queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_parameter_1" class="md-nav__link">
    get_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_progress_bar_dict" class="md-nav__link">
    get_progress_bar_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submodule_1" class="md-nav__link">
    get_submodule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#half_1" class="md-nav__link">
    half
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load_state_dict_1" class="md-nav__link">
    load_state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log" class="md-nav__link">
    log
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log_dict" class="md-nav__link">
    log_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log_grad_norm" class="md-nav__link">
    log_grad_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lr_schedulers" class="md-nav__link">
    lr_schedulers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#manual_backward" class="md-nav__link">
    manual_backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modules_1" class="md-nav__link">
    modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_buffers_1" class="md-nav__link">
    named_buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_children_1" class="md-nav__link">
    named_children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_modules_1" class="md-nav__link">
    named_modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_parameters_1" class="md-nav__link">
    named_parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_after_backward" class="md-nav__link">
    on_after_backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_after_batch_transfer" class="md-nav__link">
    on_after_batch_transfer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_backward" class="md-nav__link">
    on_before_backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_batch_transfer" class="md-nav__link">
    on_before_batch_transfer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_optimizer_step" class="md-nav__link">
    on_before_optimizer_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_zero_grad" class="md-nav__link">
    on_before_zero_grad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_epoch_end" class="md-nav__link">
    on_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_epoch_start" class="md-nav__link">
    on_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_fit_end" class="md-nav__link">
    on_fit_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_fit_start" class="md-nav__link">
    on_fit_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_hpc_load" class="md-nav__link">
    on_hpc_load
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_hpc_save" class="md-nav__link">
    on_hpc_save
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_load_checkpoint" class="md-nav__link">
    on_load_checkpoint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_post_move_to_device" class="md-nav__link">
    on_post_move_to_device
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_batch_end" class="md-nav__link">
    on_predict_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_batch_start" class="md-nav__link">
    on_predict_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_dataloader" class="md-nav__link">
    on_predict_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_end" class="md-nav__link">
    on_predict_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_epoch_end" class="md-nav__link">
    on_predict_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_epoch_start" class="md-nav__link">
    on_predict_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_model_eval" class="md-nav__link">
    on_predict_model_eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_start" class="md-nav__link">
    on_predict_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_pretrain_routine_end" class="md-nav__link">
    on_pretrain_routine_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_pretrain_routine_start" class="md-nav__link">
    on_pretrain_routine_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_save_checkpoint" class="md-nav__link">
    on_save_checkpoint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_batch_end" class="md-nav__link">
    on_test_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_batch_start" class="md-nav__link">
    on_test_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_dataloader" class="md-nav__link">
    on_test_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_end" class="md-nav__link">
    on_test_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_epoch_end" class="md-nav__link">
    on_test_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_epoch_start" class="md-nav__link">
    on_test_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_model_eval" class="md-nav__link">
    on_test_model_eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_model_train" class="md-nav__link">
    on_test_model_train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_start" class="md-nav__link">
    on_test_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_batch_end" class="md-nav__link">
    on_train_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_batch_start" class="md-nav__link">
    on_train_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_dataloader" class="md-nav__link">
    on_train_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_end" class="md-nav__link">
    on_train_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_epoch_end" class="md-nav__link">
    on_train_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_epoch_start" class="md-nav__link">
    on_train_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_start" class="md-nav__link">
    on_train_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_val_dataloader" class="md-nav__link">
    on_val_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_batch_end" class="md-nav__link">
    on_validation_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_batch_start" class="md-nav__link">
    on_validation_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_end" class="md-nav__link">
    on_validation_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_epoch_end" class="md-nav__link">
    on_validation_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_epoch_start" class="md-nav__link">
    on_validation_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_model_eval" class="md-nav__link">
    on_validation_model_eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_model_train" class="md-nav__link">
    on_validation_model_train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_start" class="md-nav__link">
    on_validation_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizer_step" class="md-nav__link">
    optimizer_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizer_zero_grad" class="md-nav__link">
    optimizer_zero_grad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizers" class="md-nav__link">
    optimizers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameters_1" class="md-nav__link">
    parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_dataloader" class="md-nav__link">
    predict_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_step" class="md-nav__link">
    predict_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prepare_data" class="md-nav__link">
    prepare_data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#print" class="md-nav__link">
    print
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_backward_hook_1" class="md-nav__link">
    register_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_buffer_1" class="md-nav__link">
    register_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_hook_1" class="md-nav__link">
    register_forward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_pre_hook_1" class="md-nav__link">
    register_forward_pre_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_full_backward_hook_1" class="md-nav__link">
    register_full_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_parameter_1" class="md-nav__link">
    register_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requires_grad__1" class="md-nav__link">
    requires_grad_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#save_hyperparameters" class="md-nav__link">
    save_hyperparameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_extra_state_1" class="md-nav__link">
    set_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setup" class="md-nav__link">
    setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#share_memory_1" class="md-nav__link">
    share_memory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#state_dict_1" class="md-nav__link">
    state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summarize" class="md-nav__link">
    summarize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tbptt_split_batch" class="md-nav__link">
    tbptt_split_batch
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#teardown" class="md-nav__link">
    teardown
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloader" class="md-nav__link">
    test_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_epoch_end" class="md-nav__link">
    test_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_step" class="md-nav__link">
    test_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_step_end" class="md-nav__link">
    test_step_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_1" class="md-nav__link">
    to
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_empty_1" class="md-nav__link">
    to_empty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_onnx" class="md-nav__link">
    to_onnx
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_torchscript" class="md-nav__link">
    to_torchscript
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toggle_optimizer" class="md-nav__link">
    toggle_optimizer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train_1" class="md-nav__link">
    train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train_dataloader" class="md-nav__link">
    train_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training_epoch_end" class="md-nav__link">
    training_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training_step" class="md-nav__link">
    training_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training_step_end" class="md-nav__link">
    training_step_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer_batch_to_device" class="md-nav__link">
    transfer_batch_to_device
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_1" class="md-nav__link">
    type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unfreeze" class="md-nav__link">
    unfreeze
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#untoggle_optimizer" class="md-nav__link">
    untoggle_optimizer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#val_dataloader" class="md-nav__link">
    val_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation_epoch_end" class="md-nav__link">
    validation_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation_step" class="md-nav__link">
    validation_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation_step_end" class="md-nav__link">
    validation_step_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xpu_1" class="md-nav__link">
    xpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zero_grad_1" class="md-nav__link">
    zero_grad
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#contrastive-representation-learning-task" class="md-nav__link">
    Contrastive representation learning task
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#classes" class="md-nav__link">
    Classes
  </a>
  
    <nav class="md-nav" aria-label="Classes">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ntxentloss" class="md-nav__link">
    NTXentLoss
  </a>
  
    <nav class="md-nav" aria-label="NTXentLoss">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#add_module" class="md-nav__link">
    add_module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apply" class="md-nav__link">
    apply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfloat16" class="md-nav__link">
    bfloat16
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffers" class="md-nav__link">
    buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children" class="md-nav__link">
    children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cpu" class="md-nav__link">
    cpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cuda" class="md-nav__link">
    cuda
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double" class="md-nav__link">
    double
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eval" class="md-nav__link">
    eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extra_repr" class="md-nav__link">
    extra_repr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#float" class="md-nav__link">
    float
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forward" class="md-nav__link">
    forward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_buffer" class="md-nav__link">
    get_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_extra_state" class="md-nav__link">
    get_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_parameter" class="md-nav__link">
    get_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submodule" class="md-nav__link">
    get_submodule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#half" class="md-nav__link">
    half
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load_state_dict" class="md-nav__link">
    load_state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modules" class="md-nav__link">
    modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_buffers" class="md-nav__link">
    named_buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_children" class="md-nav__link">
    named_children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_modules" class="md-nav__link">
    named_modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_parameters" class="md-nav__link">
    named_parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_backward_hook" class="md-nav__link">
    register_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_buffer" class="md-nav__link">
    register_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_hook" class="md-nav__link">
    register_forward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_pre_hook" class="md-nav__link">
    register_forward_pre_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_full_backward_hook" class="md-nav__link">
    register_full_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_parameter" class="md-nav__link">
    register_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requires_grad_" class="md-nav__link">
    requires_grad_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_extra_state" class="md-nav__link">
    set_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#share_memory" class="md-nav__link">
    share_memory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#state_dict" class="md-nav__link">
    state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to" class="md-nav__link">
    to
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_empty" class="md-nav__link">
    to_empty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train" class="md-nav__link">
    train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type" class="md-nav__link">
    type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xpu" class="md-nav__link">
    xpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zero_grad" class="md-nav__link">
    zero_grad
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#simclr" class="md-nav__link">
    SimCLR
  </a>
  
    <nav class="md-nav" aria-label="SimCLR">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#ancestors-in-mro_1" class="md-nav__link">
    Ancestors (in MRO)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#class-variables_1" class="md-nav__link">
    Class variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#static-methods" class="md-nav__link">
    Static methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load_from_checkpoint" class="md-nav__link">
    load_from_checkpoint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instance-variables" class="md-nav__link">
    Instance variables
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#methods_1" class="md-nav__link">
    Methods
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#add_module_1" class="md-nav__link">
    add_module
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#add_to_queue" class="md-nav__link">
    add_to_queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#all_gather" class="md-nav__link">
    all_gather
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#apply_1" class="md-nav__link">
    apply
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#backward" class="md-nav__link">
    backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bfloat16_1" class="md-nav__link">
    bfloat16
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffers_1" class="md-nav__link">
    buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#children_1" class="md-nav__link">
    children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clip_gradients" class="md-nav__link">
    clip_gradients
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_callbacks" class="md-nav__link">
    configure_callbacks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_gradient_clipping" class="md-nav__link">
    configure_gradient_clipping
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_optimizers" class="md-nav__link">
    configure_optimizers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#configure_sharded_model" class="md-nav__link">
    configure_sharded_model
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cpu_1" class="md-nav__link">
    cpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cuda_1" class="md-nav__link">
    cuda
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#double_1" class="md-nav__link">
    double
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#eval_1" class="md-nav__link">
    eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exclude_from_wt_decay" class="md-nav__link">
    exclude_from_wt_decay
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#extra_repr_1" class="md-nav__link">
    extra_repr
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#float_1" class="md-nav__link">
    float
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#forward_1" class="md-nav__link">
    forward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#freeze" class="md-nav__link">
    freeze
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_buffer_1" class="md-nav__link">
    get_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_extra_state_1" class="md-nav__link">
    get_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_from_queue" class="md-nav__link">
    get_from_queue
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_parameter_1" class="md-nav__link">
    get_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_progress_bar_dict" class="md-nav__link">
    get_progress_bar_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#get_submodule_1" class="md-nav__link">
    get_submodule
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#half_1" class="md-nav__link">
    half
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#load_state_dict_1" class="md-nav__link">
    load_state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log" class="md-nav__link">
    log
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log_dict" class="md-nav__link">
    log_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#log_grad_norm" class="md-nav__link">
    log_grad_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lr_schedulers" class="md-nav__link">
    lr_schedulers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#manual_backward" class="md-nav__link">
    manual_backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modules_1" class="md-nav__link">
    modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_buffers_1" class="md-nav__link">
    named_buffers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_children_1" class="md-nav__link">
    named_children
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_modules_1" class="md-nav__link">
    named_modules
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#named_parameters_1" class="md-nav__link">
    named_parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_after_backward" class="md-nav__link">
    on_after_backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_after_batch_transfer" class="md-nav__link">
    on_after_batch_transfer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_backward" class="md-nav__link">
    on_before_backward
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_batch_transfer" class="md-nav__link">
    on_before_batch_transfer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_optimizer_step" class="md-nav__link">
    on_before_optimizer_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_before_zero_grad" class="md-nav__link">
    on_before_zero_grad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_epoch_end" class="md-nav__link">
    on_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_epoch_start" class="md-nav__link">
    on_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_fit_end" class="md-nav__link">
    on_fit_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_fit_start" class="md-nav__link">
    on_fit_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_hpc_load" class="md-nav__link">
    on_hpc_load
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_hpc_save" class="md-nav__link">
    on_hpc_save
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_load_checkpoint" class="md-nav__link">
    on_load_checkpoint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_post_move_to_device" class="md-nav__link">
    on_post_move_to_device
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_batch_end" class="md-nav__link">
    on_predict_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_batch_start" class="md-nav__link">
    on_predict_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_dataloader" class="md-nav__link">
    on_predict_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_end" class="md-nav__link">
    on_predict_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_epoch_end" class="md-nav__link">
    on_predict_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_epoch_start" class="md-nav__link">
    on_predict_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_model_eval" class="md-nav__link">
    on_predict_model_eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_predict_start" class="md-nav__link">
    on_predict_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_pretrain_routine_end" class="md-nav__link">
    on_pretrain_routine_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_pretrain_routine_start" class="md-nav__link">
    on_pretrain_routine_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_save_checkpoint" class="md-nav__link">
    on_save_checkpoint
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_batch_end" class="md-nav__link">
    on_test_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_batch_start" class="md-nav__link">
    on_test_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_dataloader" class="md-nav__link">
    on_test_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_end" class="md-nav__link">
    on_test_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_epoch_end" class="md-nav__link">
    on_test_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_epoch_start" class="md-nav__link">
    on_test_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_model_eval" class="md-nav__link">
    on_test_model_eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_model_train" class="md-nav__link">
    on_test_model_train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_test_start" class="md-nav__link">
    on_test_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_batch_end" class="md-nav__link">
    on_train_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_batch_start" class="md-nav__link">
    on_train_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_dataloader" class="md-nav__link">
    on_train_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_end" class="md-nav__link">
    on_train_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_epoch_end" class="md-nav__link">
    on_train_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_epoch_start" class="md-nav__link">
    on_train_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_train_start" class="md-nav__link">
    on_train_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_val_dataloader" class="md-nav__link">
    on_val_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_batch_end" class="md-nav__link">
    on_validation_batch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_batch_start" class="md-nav__link">
    on_validation_batch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_end" class="md-nav__link">
    on_validation_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_epoch_end" class="md-nav__link">
    on_validation_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_epoch_start" class="md-nav__link">
    on_validation_epoch_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_model_eval" class="md-nav__link">
    on_validation_model_eval
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_model_train" class="md-nav__link">
    on_validation_model_train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#on_validation_start" class="md-nav__link">
    on_validation_start
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizer_step" class="md-nav__link">
    optimizer_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizer_zero_grad" class="md-nav__link">
    optimizer_zero_grad
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#optimizers" class="md-nav__link">
    optimizers
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameters_1" class="md-nav__link">
    parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_dataloader" class="md-nav__link">
    predict_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predict_step" class="md-nav__link">
    predict_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prepare_data" class="md-nav__link">
    prepare_data
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#print" class="md-nav__link">
    print
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_backward_hook_1" class="md-nav__link">
    register_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_buffer_1" class="md-nav__link">
    register_buffer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_hook_1" class="md-nav__link">
    register_forward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_forward_pre_hook_1" class="md-nav__link">
    register_forward_pre_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_full_backward_hook_1" class="md-nav__link">
    register_full_backward_hook
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#register_parameter_1" class="md-nav__link">
    register_parameter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#requires_grad__1" class="md-nav__link">
    requires_grad_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#save_hyperparameters" class="md-nav__link">
    save_hyperparameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set_extra_state_1" class="md-nav__link">
    set_extra_state
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#setup" class="md-nav__link">
    setup
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#share_memory_1" class="md-nav__link">
    share_memory
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#state_dict_1" class="md-nav__link">
    state_dict
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#summarize" class="md-nav__link">
    summarize
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tbptt_split_batch" class="md-nav__link">
    tbptt_split_batch
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#teardown" class="md-nav__link">
    teardown
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_dataloader" class="md-nav__link">
    test_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_epoch_end" class="md-nav__link">
    test_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_step" class="md-nav__link">
    test_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#test_step_end" class="md-nav__link">
    test_step_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_1" class="md-nav__link">
    to
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_empty_1" class="md-nav__link">
    to_empty
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_onnx" class="md-nav__link">
    to_onnx
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#to_torchscript" class="md-nav__link">
    to_torchscript
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#toggle_optimizer" class="md-nav__link">
    toggle_optimizer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train_1" class="md-nav__link">
    train
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#train_dataloader" class="md-nav__link">
    train_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training_epoch_end" class="md-nav__link">
    training_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training_step" class="md-nav__link">
    training_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#training_step_end" class="md-nav__link">
    training_step_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#transfer_batch_to_device" class="md-nav__link">
    transfer_batch_to_device
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#type_1" class="md-nav__link">
    type
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unfreeze" class="md-nav__link">
    unfreeze
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#untoggle_optimizer" class="md-nav__link">
    untoggle_optimizer
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#val_dataloader" class="md-nav__link">
    val_dataloader
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation_epoch_end" class="md-nav__link">
    validation_epoch_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation_step" class="md-nav__link">
    validation_step
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#validation_step_end" class="md-nav__link">
    validation_step_end
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#xpu_1" class="md-nav__link">
    xpu
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zero_grad_1" class="md-nav__link">
    zero_grad
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/LaurenzBeck/ophthalmology/edit/main/reference/ophthalmology/modules/simclr.md" title="Edit this page" class="md-content__button md-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20.71 7.04c.39-.39.39-1.04 0-1.41l-2.34-2.34c-.37-.39-1.02-.39-1.41 0l-1.84 1.83 3.75 3.75M3 17.25V21h3.75L17.81 9.93l-3.75-3.75L3 17.25z"/></svg>
                  </a>
                
                
                <h1 id="module-ophthalmologymodulessimclr">Module ophthalmology.modules.simclr</h1>
<h2 id="contrastive-representation-learning-task">Contrastive representation learning task</h2>
<p>SimCLR Pytorch Lightning implementation adopted from:
https://github.com/PyTorchLightning/Lightning-Bolts/blob/master/pl_bolts/models/self_supervised/simclr/simclr_module.py#L61-L300</p>
<h2 id="classes">Classes</h2>
<h3 id="ntxentloss">NTXentLoss</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">NTXentLoss</span><span class="p">(</span>
    <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">eps</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-06</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="ancestors-in-mro">Ancestors (in MRO)</h4>
<ul>
<li>torch.nn.modules.module.Module</li>
</ul>
<h4 id="class-variables">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">T_destination</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">dump_patches</span>
</code></pre></div>
<h4 id="methods">Methods</h4>
<h4 id="add_module">add_module</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add_module</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">module</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Adds a child module to the current module.</p>
<p>The module can be accessed as an attribute using the given name.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>string</td>
<td>name of the child module. The child module can be</td>
<td></td>
</tr>
<tr>
<td>accessed from this module using the given name</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>module</td>
<td>Module</td>
<td>child module to be added to the module.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="apply">apply</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">apply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)],</span> <span class="n">NoneType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Applies <code>fn</code> recursively to every submodule (as returned by <code>.children()</code>)</p>
<p>as well as self. Typical use includes initializing the parameters of a model
(see also :ref:<code>nn-init-doc</code>).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn (</td>
<td>None</td>
<td>class:<code>Module</code> -&gt; None): function to be applied to each submodule</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; @torch.no_grad()
&gt;&gt;&gt; def init_weights(m):
&gt;&gt;&gt;     print(m)
&gt;&gt;&gt;     if type(m) == nn.Linear:
&gt;&gt;&gt;         m.weight.fill_(1.0)
&gt;&gt;&gt;         print(m.weight)
&gt;&gt;&gt; net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
&gt;&gt;&gt; net.apply(init_weights)
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
        [ 1.,  1.]])
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
        [ 1.,  1.]])
Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
)
Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
) |
</code></pre></div>
<h4 id="bfloat16">bfloat16</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">bfloat16</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>bfloat16</code> datatype.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="buffers">buffers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">buffers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
</code></pre></div>
<p>Returns an iterator over module buffers.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields buffers of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only buffers that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.Tensor</td>
<td>module buffer</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for buf in model.buffers():
&gt;&gt;&gt;     print(type(buf), buf.size())
&lt;class &#39;torch.Tensor&#39;&gt; (20L,)
&lt;class &#39;torch.Tensor&#39;&gt; (20L, 1L, 5L, 5L) |
</code></pre></div>
<h4 id="children">children</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">children</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]</span>
</code></pre></div>
<p>Returns an iterator over immediate children modules.</p>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>a child module</td>
</tr>
</tbody>
</table>
<h4 id="cpu">cpu</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">cpu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Moves all model parameters and buffers to the CPU.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="cuda">cuda</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">cuda</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Moves all model parameters and buffers to the GPU.</p>
<p>This also makes associated parameters and buffers different objects. So
it should be called before constructing optimizer if the module will
live on GPU while being optimized.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device</td>
<td>int</td>
<td>if specified, all parameters will be</td>
<td></td>
</tr>
<tr>
<td>copied to that device</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="double">double</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">double</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>double</code> datatype.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="eval">eval</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Sets the module in evaluation mode.</p>
<p>This has any effect only on certain modules. See documentations of
particular modules for details of their behaviors in training/evaluation
mode, if they are affected, e.g. :class:<code>Dropout</code>, :class:<code>BatchNorm</code>,
etc.</p>
<p>This is equivalent with :meth:<code>self.train(False) &lt;torch.nn.Module.train&gt;</code>.</p>
<p>See :ref:<code>locally-disable-grad-doc</code> for a comparison between
<code>.eval()</code> and several similar mechanisms that may be confused with it.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="extra_repr">extra_repr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">extra_repr</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span>
</code></pre></div>
<p>Set the extra representation of the module</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p>
<h4 id="float">float</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">float</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>float</code> datatype.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="forward">forward</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">out_1</span><span class="p">,</span>
    <span class="n">out_2</span>
<span class="p">)</span>
</code></pre></div>
<p>assume out_1 and out_2 are normalized</p>
<p>out_1: [batch_size, dim]
out_2: [batch_size, dim]</p>
<h4 id="get_buffer">get_buffer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_buffer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Tensor&#39;</span>
</code></pre></div>
<p>Returns the buffer given by <code>target</code> if it exists,</p>
<p>otherwise throws an error.</p>
<p>See the docstring for <code>get_submodule</code> for a more detailed
explanation of this method's functionality as well as how to
correctly specify <code>target</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>None</td>
<td>The fully-qualified string name of the buffer</td>
<td></td>
</tr>
<tr>
<td>to look for. (See <code>get_submodule</code> for how to specify a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fully-qualified string.)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.Tensor</td>
<td>The buffer referenced by <code>target</code></td>
</tr>
</tbody>
</table>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>If the target string references an invalid</td>
</tr>
<tr>
<td>path or resolves to something that is not a</td>
<td></td>
</tr>
<tr>
<td>buffer</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="get_extra_state">get_extra_state</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_extra_state</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span>
</code></pre></div>
<p>Returns any extra state to include in the module's state_dict.</p>
<p>Implement this and a corresponding :func:<code>set_extra_state</code> for your module
if you need to store extra state. This function is called when building the
module's <code>state_dict()</code>.</p>
<p>Note that extra state should be pickleable to ensure working serialization
of the state_dict. We only provide provide backwards compatibility guarantees
for serializing Tensors; other objects may break backwards compatibility if
their serialized pickled form changes.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>Any extra state to store in the module's state_dict</td>
</tr>
</tbody>
</table>
<h4 id="get_parameter">get_parameter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_parameter</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Parameter&#39;</span>
</code></pre></div>
<p>Returns the parameter given by <code>target</code> if it exists,</p>
<p>otherwise throws an error.</p>
<p>See the docstring for <code>get_submodule</code> for a more detailed
explanation of this method's functionality as well as how to
correctly specify <code>target</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>None</td>
<td>The fully-qualified string name of the Parameter</td>
<td></td>
</tr>
<tr>
<td>to look for. (See <code>get_submodule</code> for how to specify a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fully-qualified string.)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.nn.Parameter</td>
<td>The Parameter referenced by <code>target</code></td>
</tr>
</tbody>
</table>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>If the target string references an invalid</td>
</tr>
<tr>
<td>path or resolves to something that is not an</td>
<td></td>
</tr>
<tr>
<td><code>nn.Parameter</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="get_submodule">get_submodule</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_submodule</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Module&#39;</span>
</code></pre></div>
<p>Returns the submodule given by <code>target</code> if it exists,</p>
<p>otherwise throws an error.</p>
<p>For example, let's say you have an <code>nn.Module</code> <code>A</code> that
looks like this:</p>
<p>.. code-block::text</p>
<div class="highlight"><pre><span></span><code>A(
    (net_b): Module(
        (net_c): Module(
            (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2))
        )
        (linear): Linear(in_features=100, out_features=200, bias=True)
    )
)
</code></pre></div>
<p>(The diagram shows an <code>nn.Module</code> <code>A</code>. <code>A</code> has a nested
submodule <code>net_b</code>, which itself has two submodules <code>net_c</code>
and <code>linear</code>. <code>net_c</code> then has a submodule <code>conv</code>.)</p>
<p>To check whether or not we have the <code>linear</code> submodule, we
would call <code>get_submodule("net_b.linear")</code>. To check whether
we have the <code>conv</code> submodule, we would call
<code>get_submodule("net_b.net_c.conv")</code>.</p>
<p>The runtime of <code>get_submodule</code> is bounded by the degree
of module nesting in <code>target</code>. A query against
<code>named_modules</code> achieves the same result, but it is O(N) in
the number of transitive modules. So, for a simple check to see
if some submodule exists, <code>get_submodule</code> should always be
used.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>None</td>
<td>The fully-qualified string name of the submodule</td>
<td></td>
</tr>
<tr>
<td>to look for. (See above example for how to specify a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fully-qualified string.)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.nn.Module</td>
<td>The submodule referenced by <code>target</code></td>
</tr>
</tbody>
</table>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>If the target string references an invalid</td>
</tr>
<tr>
<td>path or resolves to something that is not an</td>
<td></td>
</tr>
<tr>
<td><code>nn.Module</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="half">half</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">half</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>half</code> datatype.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="load_state_dict">load_state_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">load_state_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">state_dict</span><span class="p">:</span> <span class="s1">&#39;OrderedDict[str, Tensor]&#39;</span><span class="p">,</span>
    <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Copies parameters and buffers from :attr:<code>state_dict</code> into</p>
<p>this module and its descendants. If :attr:<code>strict</code> is <code>True</code>, then
the keys of :attr:<code>state_dict</code> must exactly match the keys returned
by this module's :meth:<code>~torch.nn.Module.state_dict</code> function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>state_dict</td>
<td>dict</td>
<td>a dict containing parameters and</td>
<td></td>
</tr>
<tr>
<td>persistent buffers.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>strict</td>
<td>bool</td>
<td>whether to strictly enforce that the keys</td>
<td></td>
</tr>
<tr>
<td>in :attr:<code>state_dict</code> match the keys returned by this module's</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>:meth:<code>~torch.nn.Module.state_dict</code> function. Default: <code>True</code></td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>NamedTuple</code> with <code>missing_keys</code> and <code>unexpected_keys</code> fields:</td>
</tr>
<tr>
<td>* <strong>missing_keys</strong> is a list of str containing the missing keys</td>
<td></td>
</tr>
<tr>
<td>* <strong>unexpected_keys</strong> is a list of str containing the unexpected keys</td>
<td></td>
</tr>
</tbody>
</table>
<p>Note:
    If a parameter or buffer is registered as <code>None</code> and its corresponding key
    exists in :attr:<code>state_dict</code>, :meth:<code>load_state_dict</code> will raise a
    <code>RuntimeError</code>. |</p>
<h4 id="modules">modules</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">modules</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]</span>
</code></pre></div>
<p>Returns an iterator over all modules in the network.</p>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>a module in the network</td>
</tr>
<tr>
<td>Note:</td>
<td></td>
</tr>
<tr>
<td>Duplicate modules are returned only once. In the following</td>
<td></td>
</tr>
<tr>
<td>example, <code>l</code> will be returned only once.</td>
<td></td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.modules()):
        print(idx, &#39;-&gt;&#39;, m)

0 -&gt; Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
)
1 -&gt; Linear(in_features=2, out_features=2, bias=True) |
</code></pre></div>
<h4 id="named_buffers">named_buffers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_buffers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
</code></pre></div>
<p>Returns an iterator over module buffers, yielding both the</p>
<p>name of the buffer as well as the buffer itself.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td>str</td>
<td>prefix to prepend to all buffer names.</td>
<td>None</td>
</tr>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields buffers of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only buffers that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>(string, torch.Tensor): Tuple containing the name and buffer</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for name, buf in self.named_buffers():
&gt;&gt;&gt;    if name in [&#39;running_var&#39;]:
&gt;&gt;&gt;        print(buf.size()) |
</code></pre></div>
<h4 id="named_children">named_children</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_children</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]]</span>
</code></pre></div>
<p>Returns an iterator over immediate children modules, yielding both</p>
<p>the name of the module as well as the module itself.</p>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>(string, Module): Tuple containing a name and child module</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for name, module in model.named_children():
&gt;&gt;&gt;     if name in [&#39;conv4&#39;, &#39;conv5&#39;]:
&gt;&gt;&gt;         print(module) |
</code></pre></div>
<h4 id="named_modules">named_modules</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_modules</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">memo</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">remove_duplicate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns an iterator over all modules in the network, yielding
both the name of the module as well as the module itself.</p>
<p>Args:
    memo: a memo to store the set of modules already added to the result
    prefix: a prefix that will be added to the name of the module
    remove_duplicate: whether to remove the duplicated module instances in the result
    or not</p>
<p>Yields:
    (string, Module): Tuple of name and module</p>
<p>Note:
    Duplicate modules are returned only once. In the following
    example, <code>l</code> will be returned only once.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.named_modules()):
        print(idx, &#39;-&gt;&#39;, m)

0 -&gt; (&#39;&#39;, Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
))
1 -&gt; (&#39;0&#39;, Linear(in_features=2, out_features=2, bias=True))
</code></pre></div>
<h4 id="named_parameters">named_parameters</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_parameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]]</span>
</code></pre></div>
<p>Returns an iterator over module parameters, yielding both the</p>
<p>name of the parameter as well as the parameter itself.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td>str</td>
<td>prefix to prepend to all parameter names.</td>
<td>None</td>
</tr>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields parameters of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only parameters that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>(string, Parameter): Tuple containing the name and parameter</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for name, param in self.named_parameters():
&gt;&gt;&gt;    if name in [&#39;bias&#39;]:
&gt;&gt;&gt;        print(param.size()) |
</code></pre></div>
<h4 id="parameters">parameters</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span>
</code></pre></div>
<p>Returns an iterator over module parameters.</p>
<p>This is typically passed to an optimizer.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields parameters of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only parameters that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameter</td>
<td>module parameter</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for param in model.parameters():
&gt;&gt;&gt;     print(type(param), param.size())
&lt;class &#39;torch.Tensor&#39;&gt; (20L,)
&lt;class &#39;torch.Tensor&#39;&gt; (20L, 1L, 5L, 5L) |
</code></pre></div>
<h4 id="register_backward_hook">register_backward_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_backward_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">),</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a backward hook on the module.</p>
<p>This function is deprecated in favor of :meth:<code>~torch.nn.Module.register_full_backward_hook</code> and
the behavior of this function will change in future versions.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>:class:<code>torch.utils.hooks.RemovableHandle</code>:</td>
</tr>
<tr>
<td>a handle that can be used to remove the added hook by calling</td>
<td></td>
</tr>
<tr>
<td><code>handle.remove()</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="register_buffer">register_buffer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_buffer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">tensor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="n">persistent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Adds a buffer to the module.</p>
<p>This is typically used to register a buffer that should not to be
considered a model parameter. For example, BatchNorm's <code>running_mean</code>
is not a parameter, but is part of the module's state. Buffers, by
default, are persistent and will be saved alongside parameters. This
behavior can be changed by setting :attr:<code>persistent</code> to <code>False</code>. The
only difference between a persistent buffer and a non-persistent buffer
is that the latter will not be a part of this module's
:attr:<code>state_dict</code>.</p>
<p>Buffers can be accessed as attributes using given names.</p>
<p>Args:
    name (string): name of the buffer. The buffer can be accessed
        from this module using the given name
    tensor (Tensor or None): buffer to be registered. If <code>None</code>, then operations
        that run on buffers, such as :attr:<code>cuda</code>, are ignored. If <code>None</code>,
        the buffer is <strong>not</strong> included in the module's :attr:<code>state_dict</code>.
    persistent (bool): whether the buffer is part of this module's
        :attr:<code>state_dict</code>.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; self.register_buffer(&#39;running_mean&#39;, torch.zeros(num_features))
</code></pre></div>
<h4 id="register_forward_hook">register_forward_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_forward_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a forward hook on the module.</p>
<p>The hook will be called every time after :func:<code>forward</code> has computed an output.
It should have the following signature::</p>
<div class="highlight"><pre><span></span><code>hook(module, input, output) -&gt; None or modified output
</code></pre></div>
<p>The input contains only the positional arguments given to the module.
Keyword arguments won't be passed to the hooks and only to the <code>forward</code>.
The hook can modify the output. It can modify the input inplace but
it will not have effect on forward since this is called after</p>
<h4 id="register_forward_pre_hook">register_forward_pre_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_forward_pre_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a forward pre-hook on the module.</p>
<p>The hook will be called every time before :func:<code>forward</code> is invoked.
It should have the following signature::</p>
<div class="highlight"><pre><span></span><code>hook(module, input) -&gt; None or modified input
</code></pre></div>
<p>The input contains only the positional arguments given to the module.
Keyword arguments won't be passed to the hooks and only to the <code>forward</code>.
The hook can modify the input. User can either return a tuple or a
single modified value in the hook. We will wrap the value into a tuple
if a single value is returned(unless that value is already a tuple).</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>:class:<code>torch.utils.hooks.RemovableHandle</code>:</td>
</tr>
<tr>
<td>a handle that can be used to remove the added hook by calling</td>
<td></td>
</tr>
<tr>
<td><code>handle.remove()</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="register_full_backward_hook">register_full_backward_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_full_backward_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">),</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a backward hook on the module.</p>
<p>The hook will be called every time the gradients with respect to module
inputs are computed. The hook should have the following signature::</p>
<div class="highlight"><pre><span></span><code>hook(module, grad_input, grad_output) -&gt; tuple(Tensor) or None
</code></pre></div>
<p>The :attr:<code>grad_input</code> and :attr:<code>grad_output</code> are tuples that contain the gradients
with respect to the inputs and outputs respectively. The hook should
not modify its arguments, but it can optionally return a new gradient with
respect to the input that will be used in place of :attr:<code>grad_input</code> in
subsequent computations. :attr:<code>grad_input</code> will only correspond to the inputs given
as positional arguments and all kwarg arguments are ignored. Entries
in :attr:<code>grad_input</code> and :attr:<code>grad_output</code> will be <code>None</code> for all non-Tensor
arguments.</p>
<p>For technical reasons, when this hook is applied to a Module, its forward function will
receive a view of each Tensor passed to the Module. Similarly the caller will receive a view
of each Tensor returned by the Module's forward function.</p>
<p>.. warning ::
    Modifying inputs or outputs inplace is not allowed when using backward hooks and
    will raise an error.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>:class:<code>torch.utils.hooks.RemovableHandle</code>:</td>
</tr>
<tr>
<td>a handle that can be used to remove the added hook by calling</td>
<td></td>
</tr>
<tr>
<td><code>handle.remove()</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="register_parameter">register_parameter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_parameter</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">param</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Adds a parameter to the module.</p>
<p>The parameter can be accessed as an attribute using given name.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>string</td>
<td>name of the parameter. The parameter can be accessed</td>
<td></td>
</tr>
<tr>
<td>from this module using the given name</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>param</td>
<td>Parameter or None</td>
<td>parameter to be added to the module. If</td>
<td></td>
</tr>
<tr>
<td><code>None</code>, then operations that run on parameters, such as :attr:<code>cuda</code>,</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are ignored. If <code>None</code>, the parameter is <strong>not</strong> included in the</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>module's :attr:<code>state_dict</code>.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="requires_grad_">requires_grad_</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">requires_grad_</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Change if autograd should record operations on parameters in this</p>
<p>module.</p>
<p>This method sets the parameters' :attr:<code>requires_grad</code> attributes
in-place.</p>
<p>This method is helpful for freezing part of the module for finetuning
or training parts of a model individually (e.g., GAN training).</p>
<p>See :ref:<code>locally-disable-grad-doc</code> for a comparison between
<code>.requires_grad_()</code> and several similar mechanisms that may be confused with it.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>requires_grad</td>
<td>bool</td>
<td>whether autograd should record operations on</td>
<td></td>
</tr>
<tr>
<td>parameters in this module. Default: <code>True</code>.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="set_extra_state">set_extra_state</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">set_extra_state</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">)</span>
</code></pre></div>
<p>This function is called from :func:<code>load_state_dict</code> to handle any extra state</p>
<p>found within the <code>state_dict</code>. Implement this function and a corresponding</p>
<h4 id="share_memory">share_memory</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">share_memory</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>See :meth:<code>torch.Tensor.share_memory_</code></p>
<h4 id="state_dict">state_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">state_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">destination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">keep_vars</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns a dictionary containing a whole state of the module.</p>
<p>Both parameters and persistent buffers (e.g. running averages) are
included. Keys are corresponding parameter and buffer names.
Parameters and buffers set to <code>None</code> are not included.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict</td>
<td>a dictionary containing a whole state of the module</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; module.state_dict().keys()
[&#39;bias&#39;, &#39;weight&#39;] |
</code></pre></div>
<h4 id="to">to</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>Moves and/or casts the parameters and buffers.</p>
<p>This can be called as</p>
<p>.. function:: to(device=None, dtype=None, non_blocking=False)
   :noindex:</p>
<p>.. function:: to(dtype, non_blocking=False)
   :noindex:</p>
<p>.. function:: to(tensor, non_blocking=False)
   :noindex:</p>
<p>.. function:: to(memory_format=torch.channels_last)
   :noindex:</p>
<p>Its signature is similar to :meth:<code>torch.Tensor.to</code>, but only accepts
floating point or complex :attr:<code>dtype</code>\ s. In addition, this method will
only cast the floating point or complex parameters and buffers to :attr:<code>dtype</code>
(if given). The integral parameters and buffers will be moved
:attr:<code>device</code>, if that is given, but with dtypes unchanged. When
:attr:<code>non_blocking</code> is set, it tries to convert/move asynchronously
with respect to the host if possible, e.g., moving CPU Tensors with
pinned memory to CUDA devices.</p>
<p>See below for examples.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device (</td>
<td>None</td>
<td>class:<code>torch.device</code>): the desired device of the parameters</td>
<td></td>
</tr>
<tr>
<td>and buffers in this module</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dtype (</td>
<td>None</td>
<td>class:<code>torch.dtype</code>): the desired floating point or complex dtype of</td>
<td></td>
</tr>
<tr>
<td>the parameters and buffers in this module</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tensor</td>
<td>torch.Tensor</td>
<td>Tensor whose dtype and device are the desired</td>
<td></td>
</tr>
<tr>
<td>dtype and device for all parameters and buffers in this module</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>memory_format (</td>
<td>None</td>
<td>class:<code>torch.memory_format</code>): the desired memory</td>
<td></td>
</tr>
<tr>
<td>format for 4D parameters and buffers in this module (keyword</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>only argument)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
<tr>
<td>Examples::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; linear = nn.Linear(2, 2)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1913, -0.3420],
        [-0.5113, -0.2325]])
&gt;&gt;&gt; linear.to(torch.double)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1913, -0.3420],
        [-0.5113, -0.2325]], dtype=torch.float64)
&gt;&gt;&gt; gpu1 = torch.device(&quot;cuda:1&quot;)
&gt;&gt;&gt; linear.to(gpu1, dtype=torch.half, non_blocking=True)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1914, -0.3420],
        [-0.5112, -0.2324]], dtype=torch.float16, device=&#39;cuda:1&#39;)
&gt;&gt;&gt; cpu = torch.device(&quot;cpu&quot;)
&gt;&gt;&gt; linear.to(cpu)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1914, -0.3420],
        [-0.5112, -0.2324]], dtype=torch.float16)

&gt;&gt;&gt; linear = nn.Linear(2, 2, bias=None).to(torch.cdouble)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.3741+0.j,  0.2382+0.j],
        [ 0.5593+0.j, -0.4443+0.j]], dtype=torch.complex128)
&gt;&gt;&gt; linear(torch.ones(3, 2, dtype=torch.cdouble))
tensor([[0.6122+0.j, 0.1150+0.j],
        [0.6122+0.j, 0.1150+0.j],
        [0.6122+0.j, 0.1150+0.j]], dtype=torch.complex128) |
</code></pre></div>
<h4 id="to_empty">to_empty</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to_empty</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Moves the parameters and buffers to the specified device without copying storage.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device (</td>
<td>None</td>
<td>class:<code>torch.device</code>): The desired device of the parameters</td>
<td></td>
</tr>
<tr>
<td>and buffers in this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="train">train</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Sets the module in training mode.</p>
<p>This has any effect only on certain modules. See documentations of
particular modules for details of their behaviors in training/evaluation
mode, if they are affected, e.g. :class:<code>Dropout</code>, :class:<code>BatchNorm</code>,
etc.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>mode</td>
<td>bool</td>
<td>whether to set training mode (<code>True</code>) or evaluation</td>
<td></td>
</tr>
<tr>
<td>mode (<code>False</code>). Default: <code>True</code>.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="type">type</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">type</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">dst_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Casts all parameters and buffers to :attr:<code>dst_type</code>.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>dst_type</td>
<td>type or string</td>
<td>the desired type</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="xpu">xpu</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">xpu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Moves all model parameters and buffers to the XPU.</p>
<p>This also makes associated parameters and buffers different objects. So
it should be called before constructing optimizer if the module will
live on XPU while being optimized.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device</td>
<td>int</td>
<td>if specified, all parameters will be</td>
<td></td>
</tr>
<tr>
<td>copied to that device</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="zero_grad">zero_grad</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">zero_grad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">set_to_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets gradients of all model parameters to zero. See similar function</p>
<p>under :class:<code>torch.optim.Optimizer</code> for more context.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_to_none</td>
<td>bool</td>
<td>instead of setting to zero, set the grads to None.</td>
<td></td>
</tr>
<tr>
<td>See :meth:<code>torch.optim.Optimizer.zero_grad</code> for details.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="simclr">SimCLR</h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="nc">SimCLR</span><span class="p">(</span>
    <span class="n">model</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">module</span><span class="o">.</span><span class="n">Module</span><span class="p">,</span>
    <span class="n">learning_rate</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">16</span><span class="p">,</span>
    <span class="n">print_model_info_for_input</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">epochs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">60</span><span class="p">,</span>
    <span class="n">num_train_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15378</span><span class="p">,</span>
    <span class="n">num_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">64</span><span class="p">,</span>
    <span class="n">num_hidden_projection_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">265</span><span class="p">,</span>
    <span class="n">num_projection_features</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="n">weight_decay</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
    <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span>
<span class="p">)</span>
</code></pre></div>
<h4 id="ancestors-in-mro_1">Ancestors (in MRO)</h4>
<ul>
<li>pytorch_lightning.core.lightning.LightningModule</li>
<li>pytorch_lightning.core.mixins.device_dtype_mixin.DeviceDtypeModuleMixin</li>
<li>pytorch_lightning.core.mixins.hparams_mixin.HyperparametersMixin</li>
<li>pytorch_lightning.core.saving.ModelIO</li>
<li>pytorch_lightning.core.hooks.ModelHooks</li>
<li>pytorch_lightning.core.hooks.DataHooks</li>
<li>pytorch_lightning.core.hooks.CheckpointHooks</li>
<li>torch.nn.modules.module.Module</li>
</ul>
<h4 id="class-variables_1">Class variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">CHECKPOINT_HYPER_PARAMS_KEY</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">CHECKPOINT_HYPER_PARAMS_NAME</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">CHECKPOINT_HYPER_PARAMS_TYPE</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">T_destination</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">dump_patches</span>
</code></pre></div>
<h4 id="static-methods">Static methods</h4>
<h4 id="load_from_checkpoint">load_from_checkpoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">load_from_checkpoint</span><span class="p">(</span>
    <span class="n">checkpoint_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">IO</span><span class="p">],</span>
    <span class="n">map_location</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">hparams_file</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>Primary way of loading a model from a checkpoint. When Lightning saves a checkpoint
it stores the arguments passed to <code>__init__</code>  in the checkpoint under <code>hyper_parameters</code></p>
<p>Any arguments specified through *args and **kwargs will override args stored in <code>hyper_parameters</code>.</p>
<p>Args:
    checkpoint_path: Path to checkpoint. This can also be a URL, or file-like object
    map_location:
        If your checkpoint saved a GPU model and you now load on CPUs
        or a different number of GPUs, use this to map to the new setup.
        The behaviour is the same as in :func:<code>torch.load</code>.
    hparams_file: Optional path to a .yaml file with hierarchical structure
        as in this example::</p>
<div class="highlight"><pre><span></span><code>        drop_prob: 0.2
        dataloader:
            batch_size: 32

    You most likely won&#39;t need this since Lightning will always save the hyperparameters
    to the checkpoint.
    However, if your checkpoint weights don&#39;t have the hyperparameters saved,
    use this method to pass in a .yaml file with the hparams you&#39;d like to use.
    These will be converted into a :class:`~dict` and passed into your
    :class:`LightningModule` for use.

    If your model&#39;s `hparams` argument is :class:`~argparse.Namespace`
    and .yaml file has hierarchical structure, you need to refactor your model to treat
    `hparams` as :class:`~dict`.
strict: Whether to strictly enforce that the keys in :attr:`checkpoint_path` match the keys
    returned by this module&#39;s state dict. Default: `True`.
kwargs: Any extra keyword args needed to init the model. Can also be used to override saved
    hyperparameter values.
</code></pre></div>
<p>Return:
    :class:<code>LightningModule</code> with loaded weights and hyperparameters (if available).</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code># load weights without mapping ...
MyLightningModule.load_from_checkpoint(&#39;path/to/checkpoint.ckpt&#39;)

# or load weights mapping all weights from GPU 1 to GPU 0 ...
map_location = {&#39;cuda:1&#39;:&#39;cuda:0&#39;}
MyLightningModule.load_from_checkpoint(
    &#39;path/to/checkpoint.ckpt&#39;,
    map_location=map_location
)

# or load weights and hyperparameters from separate files.
MyLightningModule.load_from_checkpoint(
    &#39;path/to/checkpoint.ckpt&#39;,
    hparams_file=&#39;/path/to/hparams_file.yaml&#39;
)

# override some of the params with new values
MyLightningModule.load_from_checkpoint(
    PATH,
    num_layers=128,
    pretrained_ckpt_path=NEW_PATH,
)

# predict
pretrained_model.eval()
pretrained_model.freeze()
y_hat = pretrained_model(x)
</code></pre></div>
<h4 id="instance-variables">Instance variables</h4>
<div class="highlight"><pre><span></span><code><span class="n">automatic_optimization</span>
</code></pre></div>
<p>If set to <code>False</code> you are responsible for calling <code>.backward()</code>, <code>.step()</code>, <code>.zero_grad()</code>.</p>
<div class="highlight"><pre><span></span><code><span class="n">current_epoch</span>
</code></pre></div>
<p>The current epoch in the Trainer.</p>
<p>If no Trainer is attached, this propery is 0.</p>
<div class="highlight"><pre><span></span><code><span class="n">device</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">dtype</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">example_input_array</span>
</code></pre></div>
<p>The example input array is a specification of what the module can consume in the :meth:<code>forward</code> method.</p>
<p>The return type is interpreted as follows:</p>
<ul>
<li>Single tensor: It is assumed the model takes a single argument, i.e.,
    <code>model.forward(model.example_input_array)</code></li>
<li>Tuple: The input array should be interpreted as a sequence of positional arguments, i.e.,
    <code>model.forward(*model.example_input_array)</code></li>
<li>Dict: The input array represents named keyword arguments, i.e.,
    <code>model.forward(**model.example_input_array)</code></li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">global_rank</span>
</code></pre></div>
<p>The index of the current process across all nodes and devices.</p>
<div class="highlight"><pre><span></span><code><span class="n">global_step</span>
</code></pre></div>
<p>Total training batches seen across all epochs.</p>
<p>If no Trainer is attached, this propery is 0.</p>
<div class="highlight"><pre><span></span><code><span class="n">hparams</span>
</code></pre></div>
<p>The collection of hyperparameters saved with :meth:<code>save_hyperparameters</code>. It is mutable by the user.</p>
<p>For the frozen set of initial hyperparameters, use :attr:<code>hparams_initial</code>.</p>
<div class="highlight"><pre><span></span><code><span class="n">hparams_initial</span>
</code></pre></div>
<p>The collection of hyperparameters saved with :meth:<code>save_hyperparameters</code>. These contents are read-only.</p>
<p>Manual updates to the saved hyperparameters can instead be performed through :attr:<code>hparams</code>.</p>
<div class="highlight"><pre><span></span><code><span class="n">loaded_optimizer_states_dict</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="n">local_rank</span>
</code></pre></div>
<p>The index of the current process within a single node.</p>
<div class="highlight"><pre><span></span><code><span class="n">logger</span>
</code></pre></div>
<p>Reference to the logger object in the Trainer.</p>
<div class="highlight"><pre><span></span><code><span class="n">model_size</span>
</code></pre></div>
<p>Returns the model size in MegaBytes (MB)</p>
<p>Note:
    This property will not return correct value for Deepspeed (stage 3) and fully-sharded training.</p>
<div class="highlight"><pre><span></span><code><span class="n">on_gpu</span>
</code></pre></div>
<p>Returns <code>True</code> if this model is currently located on a GPU.</p>
<p>Useful to set flags around the LightningModule for different CPU vs GPU behavior.</p>
<div class="highlight"><pre><span></span><code><span class="n">truncated_bptt_steps</span>
</code></pre></div>
<p>Enables <code>Truncated Backpropagation Through Time</code> in the Trainer when set to a positive integer.</p>
<p>It represents
the number of times :meth:<code>training_step</code> gets called before backpropagation. If this is &gt; 0, the</p>
<h4 id="methods_1">Methods</h4>
<h4 id="add_module_1">add_module</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add_module</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">module</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Adds a child module to the current module.</p>
<p>The module can be accessed as an attribute using the given name.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>string</td>
<td>name of the child module. The child module can be</td>
<td></td>
</tr>
<tr>
<td>accessed from this module using the given name</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>module</td>
<td>Module</td>
<td>child module to be added to the module.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="add_to_queue">add_to_queue</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">add_to_queue</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">queue</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">BaseContext</span><span class="o">.</span><span class="n">SimpleQueue</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">DefaultContext</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f0496039a90</span><span class="o">&gt;&gt;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Appends the :attr:<code>trainer.callback_metrics</code> dictionary to the given queue. To avoid issues with memory
sharing, we cast the data to numpy.</p>
<p>Args:
    queue: the instance of the queue to append the data.</p>
<p>.. deprecated:: v1.5
    This method was deprecated in v1.5 in favor of <code>DDPSpawnPlugin.add_to_queue</code>
    and will be removed in v1.7.</p>
<h4 id="all_gather">all_gather</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">all_gather</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
    <span class="n">group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sync_grads</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Allows users to call <code>self.all_gather()</code> from the LightningModule, thus making the <code>all_gather</code> operation
accelerator agnostic. <code>all_gather</code> is a function provided by accelerators to gather a tensor from several
distributed processes.</p>
<p>Args:
    data: int, float, tensor of shape (batch, ...), or a (possibly nested) collection thereof.
    group: the process group to gather results from. Defaults to all processes (world)
    sync_grads: flag that allows users to synchronize gradients for the all_gather operation</p>
<p>Return:
    A tensor of shape (world_size, batch, ...), or if the input was a collection
    the output will also be a collection with tensors of this shape.</p>
<h4 id="apply_1">apply</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">apply</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">fn</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)],</span> <span class="n">NoneType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Applies <code>fn</code> recursively to every submodule (as returned by <code>.children()</code>)</p>
<p>as well as self. Typical use includes initializing the parameters of a model
(see also :ref:<code>nn-init-doc</code>).</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>fn (</td>
<td>None</td>
<td>class:<code>Module</code> -&gt; None): function to be applied to each submodule</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; @torch.no_grad()
&gt;&gt;&gt; def init_weights(m):
&gt;&gt;&gt;     print(m)
&gt;&gt;&gt;     if type(m) == nn.Linear:
&gt;&gt;&gt;         m.weight.fill_(1.0)
&gt;&gt;&gt;         print(m.weight)
&gt;&gt;&gt; net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
&gt;&gt;&gt; net.apply(init_weights)
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
        [ 1.,  1.]])
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
        [ 1.,  1.]])
Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
)
Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
) |
</code></pre></div>
<h4 id="backward">backward</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">backward</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">loss</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">],</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called to perform backward on the loss returned in :meth:<code>training_step</code>. Override this hook with your</p>
<p>own implementation if you need to.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>loss</td>
<td>None</td>
<td>The loss tensor returned by :meth:<code>training_step</code>. If gradient accumulation is used, the loss here</td>
<td></td>
</tr>
<tr>
<td>holds the normalized value (scaled by 1 / accumulation steps).</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>optimizer</td>
<td>None</td>
<td>Current optimizer being used. <code>None</code> if using manual optimization.</td>
<td>None</td>
</tr>
<tr>
<td>optimizer_idx</td>
<td>None</td>
<td>Index of the current optimizer being used. <code>None</code> if using manual optimization.</td>
<td></td>
</tr>
<tr>
<td>Example::</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>def backward</td>
<td>self, loss, optimizer, optimizer_idx</td>
<td>loss.backward()</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="bfloat16_1">bfloat16</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">bfloat16</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>bfloat16</code> datatype.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="buffers_1">buffers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">buffers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]</span>
</code></pre></div>
<p>Returns an iterator over module buffers.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields buffers of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only buffers that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.Tensor</td>
<td>module buffer</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for buf in model.buffers():
&gt;&gt;&gt;     print(type(buf), buf.size())
&lt;class &#39;torch.Tensor&#39;&gt; (20L,)
&lt;class &#39;torch.Tensor&#39;&gt; (20L, 1L, 5L, 5L) |
</code></pre></div>
<h4 id="children_1">children</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">children</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]</span>
</code></pre></div>
<p>Returns an iterator over immediate children modules.</p>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>a child module</td>
</tr>
</tbody>
</table>
<h4 id="clip_gradients">clip_gradients</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">clip_gradients</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span>
    <span class="n">gradient_clip_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gradient_clip_algorithm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Handles gradient clipping internally.</p>
<p>Note:
    Do not override this method. If you want to customize gradient clipping, consider
    using :meth:<code>configure_gradient_clipping</code> method.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>optimizer</td>
<td>None</td>
<td>Current optimizer being used.</td>
<td>None</td>
</tr>
<tr>
<td>gradient_clip_val</td>
<td>None</td>
<td>The value at which to clip gradients.</td>
<td>None</td>
</tr>
<tr>
<td>gradient_clip_algorithm</td>
<td>None</td>
<td>The gradient clipping algorithm to use. Pass <code>gradient_clip_algorithm="value"</code></td>
<td></td>
</tr>
<tr>
<td>to clip by value, and <code>gradient_clip_algorithm="norm"</code> to clip by norm.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="configure_callbacks">configure_callbacks</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">configure_callbacks</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Configure model-specific callbacks. When the model gets attached, e.g., when <code>.fit()</code> or <code>.test()</code></p>
<p>gets called, the list returned here will be merged with the list of callbacks passed to the Trainer's
<code>callbacks</code> argument. If a callback returned here has the same type as one or several callbacks already
present in the Trainer's callbacks list, it will take priority and replace them. In addition, Lightning
will make sure :class:<code>~pytorch_lightning.callbacks.model_checkpoint.ModelCheckpoint</code> callbacks run last.</p>
<p>Return:
    A list of callbacks which will extend the list of callbacks in the Trainer.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def configure_callbacks(self):
    early_stop = EarlyStopping(monitor=&quot;val_acc&quot;, mode=&quot;max&quot;)
    checkpoint = ModelCheckpoint(monitor=&quot;val_loss&quot;)
    return [early_stop, checkpoint]
</code></pre></div>
<p>Note:
    Certain callback methods like :meth:<code>~pytorch_lightning.callbacks.base.Callback.on_init_start</code>
    will never be invoked on the new callbacks returned here.</p>
<h4 id="configure_gradient_clipping">configure_gradient_clipping</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">configure_gradient_clipping</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">gradient_clip_val</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gradient_clip_algorithm</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span>
</code></pre></div>
<p>Perform gradient clipping for the optimizer parameters. Called before :meth:<code>optimizer_step</code>.</p>
<p>Args:
    optimizer: Current optimizer being used.
    optimizer_idx: Index of the current optimizer being used.
    gradient_clip_val: The value at which to clip gradients. By default value passed in Trainer
        will be available here.
    gradient_clip_algorithm: The gradient clipping algorithm to use. By default value
        passed in Trainer will be available here.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code># Perform gradient clipping on gradients associated with discriminator (optimizer_idx=1) in GAN
def configure_gradient_clipping(self, optimizer, optimizer_idx, gradient_clip_val, gradient_clip_algorithm):
    if optimizer_idx == 1:
        # Lightning will handle the gradient clipping
        self.clip_gradients(
            optimizer,
            gradient_clip_val=gradient_clip_val,
            gradient_clip_algorithm=gradient_clip_algorithm
        )
    else:
        # implement your own custom logic to clip gradients for generator (optimizer_idx=0)
</code></pre></div>
<h4 id="configure_optimizers">configure_optimizers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">configure_optimizers</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span>
</code></pre></div>
<p>Choose what optimizers and learning-rate schedulers to use in your optimization.</p>
<p>Normally you'd need one. But in the case of GANs or similar you might have multiple.</p>
<p>Return:
    Any of these 6 options.</p>
<div class="highlight"><pre><span></span><code>- **Single optimizer**.
- **List or Tuple** of optimizers.
- **Two lists** - The first list has multiple optimizers, and the second has multiple LR schedulers
  (or multiple ``lr_scheduler_config``).
- **Dictionary**, with an ``&quot;optimizer&quot;`` key, and (optionally) a ``&quot;lr_scheduler&quot;``
  key whose value is a single LR scheduler or ``lr_scheduler_config``.
- **Tuple of dictionaries** as described above, with an optional ``&quot;frequency&quot;`` key.
- **None** - Fit will run without any optimizer.
</code></pre></div>
<p>The <code>lr_scheduler_config</code> is a dictionary which contains the scheduler and its associated configuration.
The default configuration is shown below.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code>lr_scheduler_config = {
    # REQUIRED: The scheduler instance
    &quot;scheduler&quot;: lr_scheduler,
    # The unit of the scheduler&#39;s step size, could also be &#39;step&#39;.
    # &#39;epoch&#39; updates the scheduler on epoch end whereas &#39;step&#39;
    # updates it after a optimizer update.
    &quot;interval&quot;: &quot;epoch&quot;,
    # How many epochs/steps should pass between calls to
    # `scheduler.step()`. 1 corresponds to updating the learning
    # rate after every epoch/step.
    &quot;frequency&quot;: 1,
    # Metric to to monitor for schedulers like `ReduceLROnPlateau`
    &quot;monitor&quot;: &quot;val_loss&quot;,
    # If set to `True`, will enforce that the value specified &#39;monitor&#39;
    # is available when the scheduler is updated, thus stopping
    # training if not found. If set to `False`, it will only produce a warning
    &quot;strict&quot;: True,
    # If using the `LearningRateMonitor` callback to monitor the
    # learning rate progress, this keyword can be used to specify
    # a custom logged name
    &quot;name&quot;: None,
}
</code></pre></div>
<p>When there are schedulers in which the <code>.step()</code> method is conditioned on a value, such as the</p>
<h4 id="configure_sharded_model">configure_sharded_model</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">configure_sharded_model</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Hook to create modules in a distributed aware context. This is useful for when using sharded plugins,</p>
<p>where we'd like to shard the model instantly, which is useful for extremely large models which can save
memory and initialization time.</p>
<p>This hook is called during each of fit/val/test/predict stages in the same process, so ensure that
implementation of this hook is idempotent.</p>
<h4 id="cpu_1">cpu</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">cpu</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Moves all model parameters and buffers to the CPU.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="cuda_1">cuda</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">cuda</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Moves all model parameters and buffers to the GPU. This also makes associated parameters and buffers</p>
<p>different objects. So it should be called before constructing optimizer if the module will live on GPU
while being optimized.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device</td>
<td>None</td>
<td>if specified, all parameters will be</td>
<td></td>
</tr>
<tr>
<td>copied to that device</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="double_1">double</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">double</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>double</code> datatype.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="eval_1">eval</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">eval</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Sets the module in evaluation mode.</p>
<p>This has any effect only on certain modules. See documentations of
particular modules for details of their behaviors in training/evaluation
mode, if they are affected, e.g. :class:<code>Dropout</code>, :class:<code>BatchNorm</code>,
etc.</p>
<p>This is equivalent with :meth:<code>self.train(False) &lt;torch.nn.Module.train&gt;</code>.</p>
<p>See :ref:<code>locally-disable-grad-doc</code> for a comparison between
<code>.eval()</code> and several similar mechanisms that may be confused with it.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="exclude_from_wt_decay">exclude_from_wt_decay</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">exclude_from_wt_decay</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">named_params</span><span class="p">,</span>
    <span class="n">weight_decay</span><span class="p">,</span>
    <span class="n">skip_list</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;bn&#39;</span><span class="p">)</span>
<span class="p">)</span>
</code></pre></div>
<p>Prepare the parameters to only weight-decay non bias and bn layers.</p>
<p>This has proven to be a best practice.
Code from: https://github.com/PyTorchLightning/lightning-bolts/blob/master/pl_bolts/models/self_supervised/simclr/simclr_module.py</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>named_params</td>
<td>[type]</td>
<td>[description]</td>
<td>None</td>
</tr>
<tr>
<td>weight_decay</td>
<td>[type]</td>
<td>[description]</td>
<td>None</td>
</tr>
<tr>
<td>skip_list</td>
<td>tuple</td>
<td>[description]. Defaults to ("bias", "bn").</td>
<td>("bias", "bn")</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>[type]</td>
<td>[description]</td>
</tr>
</tbody>
</table>
<h4 id="extra_repr_1">extra_repr</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">extra_repr</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span>
</code></pre></div>
<p>Set the extra representation of the module</p>
<p>To print customized extra information, you should re-implement
this method in your own modules. Both single-line and multi-line
strings are acceptable.</p>
<h4 id="float_1">float</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">float</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>float</code> datatype.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="forward_1">forward</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">forward</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">x</span>
<span class="p">)</span>
</code></pre></div>
<p>Same as :meth:<code>torch.nn.Module.forward()</code>.</p>
<p>Args:
    <em>args: Whatever you decide to pass into the forward method.
    </em>*kwargs: Keyword arguments are also possible.</p>
<p>Return:
    Your model's output</p>
<h4 id="freeze">freeze</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Freeze all params for inference.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>model = MyLightningModule(...)
model.freeze()
</code></pre></div>
<h4 id="get_buffer_1">get_buffer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_buffer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Tensor&#39;</span>
</code></pre></div>
<p>Returns the buffer given by <code>target</code> if it exists,</p>
<p>otherwise throws an error.</p>
<p>See the docstring for <code>get_submodule</code> for a more detailed
explanation of this method's functionality as well as how to
correctly specify <code>target</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>None</td>
<td>The fully-qualified string name of the buffer</td>
<td></td>
</tr>
<tr>
<td>to look for. (See <code>get_submodule</code> for how to specify a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fully-qualified string.)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.Tensor</td>
<td>The buffer referenced by <code>target</code></td>
</tr>
</tbody>
</table>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>If the target string references an invalid</td>
</tr>
<tr>
<td>path or resolves to something that is not a</td>
<td></td>
</tr>
<tr>
<td>buffer</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="get_extra_state_1">get_extra_state</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_extra_state</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span>
</code></pre></div>
<p>Returns any extra state to include in the module's state_dict.</p>
<p>Implement this and a corresponding :func:<code>set_extra_state</code> for your module
if you need to store extra state. This function is called when building the
module's <code>state_dict()</code>.</p>
<p>Note that extra state should be pickleable to ensure working serialization
of the state_dict. We only provide provide backwards compatibility guarantees
for serializing Tensors; other objects may break backwards compatibility if
their serialized pickled form changes.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>object</td>
<td>Any extra state to store in the module's state_dict</td>
</tr>
</tbody>
</table>
<h4 id="get_from_queue">get_from_queue</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_from_queue</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">queue</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">bound</span> <span class="n">method</span> <span class="n">BaseContext</span><span class="o">.</span><span class="n">SimpleQueue</span> <span class="n">of</span> <span class="o">&lt;</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">DefaultContext</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x7f0496039a90</span><span class="o">&gt;&gt;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Retrieve the :attr:<code>trainer.callback_metrics</code> dictionary from the given queue. To preserve consistency,
we cast back the data to <code>torch.Tensor</code>.</p>
<p>Args:
    queue: the instance of the queue from where to get the data.</p>
<p>.. deprecated:: v1.5
    This method was deprecated in v1.5 in favor of <code>DDPSpawnPlugin.get_from_queue</code>
    and will be removed in v1.7.</p>
<h4 id="get_parameter_1">get_parameter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_parameter</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Parameter&#39;</span>
</code></pre></div>
<p>Returns the parameter given by <code>target</code> if it exists,</p>
<p>otherwise throws an error.</p>
<p>See the docstring for <code>get_submodule</code> for a more detailed
explanation of this method's functionality as well as how to
correctly specify <code>target</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>None</td>
<td>The fully-qualified string name of the Parameter</td>
<td></td>
</tr>
<tr>
<td>to look for. (See <code>get_submodule</code> for how to specify a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fully-qualified string.)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.nn.Parameter</td>
<td>The Parameter referenced by <code>target</code></td>
</tr>
</tbody>
</table>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>If the target string references an invalid</td>
</tr>
<tr>
<td>path or resolves to something that is not an</td>
<td></td>
</tr>
<tr>
<td><code>nn.Parameter</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="get_progress_bar_dict">get_progress_bar_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_progress_bar_dict</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span>
</code></pre></div>
<h4 id="get_submodule_1">get_submodule</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">get_submodule</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Module&#39;</span>
</code></pre></div>
<p>Returns the submodule given by <code>target</code> if it exists,</p>
<p>otherwise throws an error.</p>
<p>For example, let's say you have an <code>nn.Module</code> <code>A</code> that
looks like this:</p>
<p>.. code-block::text</p>
<div class="highlight"><pre><span></span><code>A(
    (net_b): Module(
        (net_c): Module(
            (conv): Conv2d(16, 33, kernel_size=(3, 3), stride=(2, 2))
        )
        (linear): Linear(in_features=100, out_features=200, bias=True)
    )
)
</code></pre></div>
<p>(The diagram shows an <code>nn.Module</code> <code>A</code>. <code>A</code> has a nested
submodule <code>net_b</code>, which itself has two submodules <code>net_c</code>
and <code>linear</code>. <code>net_c</code> then has a submodule <code>conv</code>.)</p>
<p>To check whether or not we have the <code>linear</code> submodule, we
would call <code>get_submodule("net_b.linear")</code>. To check whether
we have the <code>conv</code> submodule, we would call
<code>get_submodule("net_b.net_c.conv")</code>.</p>
<p>The runtime of <code>get_submodule</code> is bounded by the degree
of module nesting in <code>target</code>. A query against
<code>named_modules</code> achieves the same result, but it is O(N) in
the number of transitive modules. So, for a simple check to see
if some submodule exists, <code>get_submodule</code> should always be
used.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>target</td>
<td>None</td>
<td>The fully-qualified string name of the submodule</td>
<td></td>
</tr>
<tr>
<td>to look for. (See above example for how to specify a</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>fully-qualified string.)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>torch.nn.Module</td>
<td>The submodule referenced by <code>target</code></td>
</tr>
</tbody>
</table>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AttributeError</td>
<td>If the target string references an invalid</td>
</tr>
<tr>
<td>path or resolves to something that is not an</td>
<td></td>
</tr>
<tr>
<td><code>nn.Module</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="half_1">half</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">half</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Casts all floating point parameters and buffers to <code>half</code> datatype.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="load_state_dict_1">load_state_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">load_state_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">state_dict</span><span class="p">:</span> <span class="s1">&#39;OrderedDict[str, Tensor]&#39;</span><span class="p">,</span>
    <span class="n">strict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Copies parameters and buffers from :attr:<code>state_dict</code> into</p>
<p>this module and its descendants. If :attr:<code>strict</code> is <code>True</code>, then
the keys of :attr:<code>state_dict</code> must exactly match the keys returned
by this module's :meth:<code>~torch.nn.Module.state_dict</code> function.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>state_dict</td>
<td>dict</td>
<td>a dict containing parameters and</td>
<td></td>
</tr>
<tr>
<td>persistent buffers.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>strict</td>
<td>bool</td>
<td>whether to strictly enforce that the keys</td>
<td></td>
</tr>
<tr>
<td>in :attr:<code>state_dict</code> match the keys returned by this module's</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>:meth:<code>~torch.nn.Module.state_dict</code> function. Default: <code>True</code></td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td><code>NamedTuple</code> with <code>missing_keys</code> and <code>unexpected_keys</code> fields:</td>
</tr>
<tr>
<td>* <strong>missing_keys</strong> is a list of str containing the missing keys</td>
<td></td>
</tr>
<tr>
<td>* <strong>unexpected_keys</strong> is a list of str containing the unexpected keys</td>
<td></td>
</tr>
</tbody>
</table>
<p>Note:
    If a parameter or buffer is registered as <code>None</code> and its corresponding key
    exists in :attr:<code>state_dict</code>, :meth:<code>load_state_dict</code> will raise a
    <code>RuntimeError</code>. |</p>
<h4 id="log">log</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">log</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torchmetrics</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">Metric</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">torchmetrics</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">Metric</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]],</span>
    <span class="n">prog_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">on_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">on_epoch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduce_fx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span>
    <span class="n">tbptt_reduce_fx</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tbptt_pad_token</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">enable_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sync_dist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sync_dist_op</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sync_dist_group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">add_dataloader_idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">metric_attribute</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rank_zero_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Log a key, value pair.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>self.log(&#39;train_loss&#39;, loss)
</code></pre></div>
<p>The default behavior per hook is as follows:</p>
<p>.. csv-table:: <code>*</code> also applies to the test loop
   :header: "LightningModule Hook", "on_step", "on_epoch", "prog_bar", "logger"
   :widths: 20, 10, 10, 10, 10</p>
<p>"training_step", "T", "F", "F", "T"
   "training_step_end", "T", "F", "F", "T"
   "training_epoch_end", "F", "T", "F", "T"
   "validation_step<em>", "F", "T", "F", "T"
   "validation_step_end</em>", "F", "T", "F", "T"
   "validation_epoch_end*", "F", "T", "F", "T"</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>None</td>
<td>key to log</td>
<td>None</td>
</tr>
<tr>
<td>value</td>
<td>None</td>
<td>value to log. Can be a <code>float</code>, <code>Tensor</code>, <code>Metric</code>, or a dictionary of the former.</td>
<td>None</td>
</tr>
<tr>
<td>prog_bar</td>
<td>None</td>
<td>if True logs to the progress bar</td>
<td>None</td>
</tr>
<tr>
<td>logger</td>
<td>None</td>
<td>if True logs to the logger</td>
<td>None</td>
</tr>
<tr>
<td>on_step</td>
<td>None</td>
<td>if True logs at this step. None auto-logs at the training_step but not validation/test_step</td>
<td>None</td>
</tr>
<tr>
<td>on_epoch</td>
<td>None</td>
<td>if True logs epoch accumulated metrics. None auto-logs at the val/test step but not training_step</td>
<td>None</td>
</tr>
<tr>
<td>reduce_fx</td>
<td>None</td>
<td>reduction function over step values for end of epoch. :meth:<code>torch.mean</code> by default.</td>
<td>None</td>
</tr>
<tr>
<td>enable_graph</td>
<td>None</td>
<td>if True, will not auto detach the graph</td>
<td>None</td>
</tr>
<tr>
<td>sync_dist</td>
<td>None</td>
<td>if True, reduces the metric across GPUs/TPUs. Use with care as this may lead to a significant</td>
<td></td>
</tr>
<tr>
<td>communication overhead.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sync_dist_group</td>
<td>None</td>
<td>the ddp group to sync across</td>
<td>None</td>
</tr>
<tr>
<td>add_dataloader_idx</td>
<td>None</td>
<td>if True, appends the index of the current dataloader to</td>
<td></td>
</tr>
<tr>
<td>the name (when using multiple). If False, user needs to give unique names for</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>each dataloader to not mix values</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>batch_size</td>
<td>None</td>
<td>Current batch_size. This will be directly inferred from the loaded batch,</td>
<td></td>
</tr>
<tr>
<td>but some data structures might need to explicitly provide it.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>metric_attribute</td>
<td>None</td>
<td>To restore the metric state, Lightning requires the reference of the</td>
<td></td>
</tr>
<tr>
<td>:class:<code>torchmetrics.Metric</code> in your model. This is found automatically if it is a model attribute.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rank_zero_only</td>
<td>None</td>
<td>Whether the value will be logged only on rank 0. This will prevent synchronization which</td>
<td></td>
</tr>
<tr>
<td>would produce a deadlock as not all processes would perform this log call.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="log_dict">log_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">log_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dictionary</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">torchmetrics</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">Metric</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">torchmetrics</span><span class="o">.</span><span class="n">metric</span><span class="o">.</span><span class="n">Metric</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]]],</span>
    <span class="n">prog_bar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">on_step</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">on_epoch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">reduce_fx</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;default&#39;</span><span class="p">,</span>
    <span class="n">tbptt_reduce_fx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">tbptt_pad_token</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">enable_graph</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sync_dist</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">sync_dist_op</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sync_dist_group</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">add_dataloader_idx</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">batch_size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">rank_zero_only</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Log a dictionary of values at once.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>values = {&#39;loss&#39;: loss, &#39;acc&#39;: acc, ..., &#39;metric_n&#39;: metric_n}
self.log_dict(values)
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>dictionary</td>
<td>None</td>
<td>key value pairs.</td>
<td></td>
</tr>
<tr>
<td>The values can be a <code>float</code>, <code>Tensor</code>, <code>Metric</code>, or a dictionary of the former.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>prog_bar</td>
<td>None</td>
<td>if True logs to the progress base</td>
<td>None</td>
</tr>
<tr>
<td>logger</td>
<td>None</td>
<td>if True logs to the logger</td>
<td>None</td>
</tr>
<tr>
<td>on_step</td>
<td>None</td>
<td>if True logs at this step. None auto-logs for training_step but not validation/test_step</td>
<td>None</td>
</tr>
<tr>
<td>on_epoch</td>
<td>None</td>
<td>if True logs epoch accumulated metrics. None auto-logs for val/test step but not training_step</td>
<td>None</td>
</tr>
<tr>
<td>reduce_fx</td>
<td>None</td>
<td>reduction function over step values for end of epoch. :meth:<code>torch.mean</code> by default.</td>
<td>None</td>
</tr>
<tr>
<td>enable_graph</td>
<td>None</td>
<td>if True, will not auto detach the graph</td>
<td>None</td>
</tr>
<tr>
<td>sync_dist</td>
<td>None</td>
<td>if True, reduces the metric across GPUs/TPUs. Use with care as this may lead to a significant</td>
<td></td>
</tr>
<tr>
<td>communication overhead.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>sync_dist_group</td>
<td>None</td>
<td>the ddp group sync across</td>
<td>None</td>
</tr>
<tr>
<td>add_dataloader_idx</td>
<td>None</td>
<td>if True, appends the index of the current dataloader to</td>
<td></td>
</tr>
<tr>
<td>the name (when using multiple). If False, user needs to give unique names for</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>each dataloader to not mix values</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>batch_size</td>
<td>None</td>
<td>Current batch_size. This will be directly inferred from the loaded batch,</td>
<td></td>
</tr>
<tr>
<td>but some data structures might need to explicitly provide it.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>rank_zero_only</td>
<td>None</td>
<td>Whether the value will be logged only on rank 0. This will prevent synchronization which</td>
<td></td>
</tr>
<tr>
<td>would produce a deadlock as not all processes would perform this log call.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="log_grad_norm">log_grad_norm</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">log_grad_norm</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">grad_norm_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Override this method to change the default behaviour of <code>log_grad_norm</code>.</p>
<p>If clipping gradients, the gradients will not have been clipped yet.</p>
<p>Args:
    grad_norm_dict: Dictionary containing current grad norm metrics</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code># DEFAULT
def log_grad_norm(self, grad_norm_dict):
    self.log_dict(grad_norm_dict, on_step=False, on_epoch=True, prog_bar=False, logger=True)
</code></pre></div>
<h4 id="lr_schedulers">lr_schedulers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">lr_schedulers</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">]</span>
</code></pre></div>
<p>Returns the learning rate scheduler(s) that are being used during training. Useful for manual</p>
<p>optimization.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A single scheduler, or a list of schedulers in case multiple ones are present, or <code>None</code> if no</td>
</tr>
<tr>
<td>schedulers were returned in :meth:<code>configure_optimizers</code>.</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="manual_backward">manual_backward</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">manual_backward</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">loss</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Call this directly from your :meth:<code>training_step</code> when doing optimizations manually. By using this,</p>
<p>Lightning can ensure that all the proper scaling gets applied when using mixed precision.</p>
<p>See :ref:<code>manual optimization&lt;common/optimizers:Manual optimization&gt;</code> for more examples.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def training_step(...):
    opt = self.optimizers()
    loss = ...
    opt.zero_grad()
    # automatically applies scaling, etc...
    self.manual_backward(loss)
    opt.step()
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>loss</td>
<td>None</td>
<td>The tensor on which to compute gradients. Must have a graph attached.</td>
<td>None</td>
</tr>
<tr>
<td>*args</td>
<td>None</td>
<td>Additional positional arguments to be forwarded to :meth:<code>~torch.Tensor.backward</code></td>
<td>None</td>
</tr>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>Additional keyword arguments to be forwarded to :meth:<code>~torch.Tensor.backward</code></td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="modules_1">modules</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">modules</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]</span>
</code></pre></div>
<p>Returns an iterator over all modules in the network.</p>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>a module in the network</td>
</tr>
<tr>
<td>Note:</td>
<td></td>
</tr>
<tr>
<td>Duplicate modules are returned only once. In the following</td>
<td></td>
</tr>
<tr>
<td>example, <code>l</code> will be returned only once.</td>
<td></td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.modules()):
        print(idx, &#39;-&gt;&#39;, m)

0 -&gt; Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
)
1 -&gt; Linear(in_features=2, out_features=2, bias=True) |
</code></pre></div>
<h4 id="named_buffers_1">named_buffers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_buffers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
</code></pre></div>
<p>Returns an iterator over module buffers, yielding both the</p>
<p>name of the buffer as well as the buffer itself.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td>str</td>
<td>prefix to prepend to all buffer names.</td>
<td>None</td>
</tr>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields buffers of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only buffers that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>(string, torch.Tensor): Tuple containing the name and buffer</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for name, buf in self.named_buffers():
&gt;&gt;&gt;    if name in [&#39;running_var&#39;]:
&gt;&gt;&gt;        print(buf.size()) |
</code></pre></div>
<h4 id="named_children_1">named_children</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_children</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]]</span>
</code></pre></div>
<p>Returns an iterator over immediate children modules, yielding both</p>
<p>the name of the module as well as the module itself.</p>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>(string, Module): Tuple containing a name and child module</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for name, module in model.named_children():
&gt;&gt;&gt;     if name in [&#39;conv4&#39;, &#39;conv5&#39;]:
&gt;&gt;&gt;         print(module) |
</code></pre></div>
<h4 id="named_modules_1">named_modules</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_modules</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">memo</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">)]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">remove_duplicate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns an iterator over all modules in the network, yielding
both the name of the module as well as the module itself.</p>
<p>Args:
    memo: a memo to store the set of modules already added to the result
    prefix: a prefix that will be added to the name of the module
    remove_duplicate: whether to remove the duplicated module instances in the result
    or not</p>
<p>Yields:
    (string, Module): Tuple of name and module</p>
<p>Note:
    Duplicate modules are returned only once. In the following
    example, <code>l</code> will be returned only once.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.named_modules()):
        print(idx, &#39;-&gt;&#39;, m)

0 -&gt; (&#39;&#39;, Sequential(
  (0): Linear(in_features=2, out_features=2, bias=True)
  (1): Linear(in_features=2, out_features=2, bias=True)
))
1 -&gt; (&#39;0&#39;, Linear(in_features=2, out_features=2, bias=True))
</code></pre></div>
<h4 id="named_parameters_1">named_parameters</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">named_parameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]]</span>
</code></pre></div>
<p>Returns an iterator over module parameters, yielding both the</p>
<p>name of the parameter as well as the parameter itself.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>prefix</td>
<td>str</td>
<td>prefix to prepend to all parameter names.</td>
<td>None</td>
</tr>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields parameters of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only parameters that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>(string, Parameter): Tuple containing the name and parameter</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for name, param in self.named_parameters():
&gt;&gt;&gt;    if name in [&#39;bias&#39;]:
&gt;&gt;&gt;        print(param.size()) |
</code></pre></div>
<h4 id="on_after_backward">on_after_backward</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_after_backward</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called after <code>loss.backward()</code> and before optimizers are stepped.</p>
<p>Note:
    If using native AMP, the gradients will not be unscaled at this point.
    Use the <code>on_before_optimizer_step</code> if you need the unscaled gradients.</p>
<h4 id="on_after_batch_transfer">on_after_batch_transfer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_after_batch_transfer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span>
</code></pre></div>
<p>Override to alter or apply batch augmentations to your batch after it is transferred to the device.</p>
<p>Note:
    To check the current state of execution of this hook you can use
    <code>self.trainer.training/testing/validating/predicting</code> so that you can
    add different logic as per your requirement.</p>
<p>Note:
    This hook only runs on single GPU training and DDP (no data-parallel).
    Data-Parallel support will come in near future.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>A batch of data that needs to be altered or augmented.</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>The index of the dataloader to which the batch belongs.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A batch of data</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def on_after_batch_transfer(self, batch, dataloader_idx):
    batch[&#39;x&#39;] = gpu_transforms(batch[&#39;x&#39;])
    return batch |
</code></pre></div>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MisconfigurationException</td>
<td>If using data-parallel, <code>Trainer(strategy='dp')</code>.</td>
</tr>
</tbody>
</table>
<p>See Also: |
| -  | meth:<code>on_before_batch_transfer</code> |
| -  | meth:<code>transfer_batch_to_device</code> |</p>
<h4 id="on_before_backward">on_before_backward</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_before_backward</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">loss</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called before <code>loss.backward()</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>loss</td>
<td>None</td>
<td>Loss divided by number of batches for gradient accumulation and scaled if using native AMP.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_before_batch_transfer">on_before_batch_transfer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_before_batch_transfer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span>
</code></pre></div>
<p>Override to alter or apply batch augmentations to your batch before it is transferred to the device.</p>
<p>Note:
    To check the current state of execution of this hook you can use
    <code>self.trainer.training/testing/validating/predicting</code> so that you can
    add different logic as per your requirement.</p>
<p>Note:
    This hook only runs on single GPU training and DDP (no data-parallel).
    Data-Parallel support will come in near future.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>A batch of data that needs to be altered or augmented.</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>The index of the dataloader to which the batch belongs.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A batch of data</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def on_before_batch_transfer(self, batch, dataloader_idx):
    batch[&#39;x&#39;] = transforms(batch[&#39;x&#39;])
    return batch |
</code></pre></div>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MisconfigurationException</td>
<td>If using data-parallel, <code>Trainer(strategy='dp')</code>.</td>
</tr>
</tbody>
</table>
<p>See Also: |
| -  | meth:<code>on_after_batch_transfer</code> |
| -  | meth:<code>transfer_batch_to_device</code> |</p>
<h4 id="on_before_optimizer_step">on_before_optimizer_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_before_optimizer_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called before <code>optimizer.step()</code>.</p>
<p>The hook is only called if gradients do not need to be accumulated.
See: :paramref:<code>~pytorch_lightning.trainer.Trainer.accumulate_grad_batches</code>.</p>
<p>If using native AMP, the loss will be unscaled before calling this hook.
See these <code>docs &lt;https://pytorch.org/docs/stable/notes/amp_examples.html#working-with-unscaled-gradients&gt;</code>__
for more information on the scaling of gradients.</p>
<p>If clipping gradients, the gradients will not have been clipped yet.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>optimizer</td>
<td>None</td>
<td>Current optimizer being used.</td>
<td>None</td>
</tr>
<tr>
<td>optimizer_idx</td>
<td>None</td>
<td>Index of the current optimizer being used.</td>
<td></td>
</tr>
<tr>
<td>Example::</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>def on_before_optimizer_step</td>
<td>self, optimizer, optimizer_idx</td>
<td># example to inspect gradient information in tensorboard</td>
<td></td>
</tr>
<tr>
<td>if self.trainer.global_step % 25 == 0:  # don't make the tf file huge</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>for k, v in self.named_parameters():</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>self.logger.experiment.add_histogram(</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>tag=k, values=v.grad, global_step=self.trainer.global_step</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>)</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="on_before_zero_grad">on_before_zero_grad</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_before_zero_grad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called after <code>training_step()</code> and before <code>optimizer.zero_grad()</code>.</p>
<p>Called in the training loop after taking an optimizer step and before zeroing grads.
Good place to inspect weight information with weights updated.</p>
<p>This is where it is called::</p>
<div class="highlight"><pre><span></span><code>for optimizer in optimizers:
    out = training_step(...)

    model.on_before_zero_grad(optimizer) # &lt; ---- called here
    optimizer.zero_grad()

    backward()
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>optimizer</td>
<td>None</td>
<td>The optimizer for which grads should be zeroed.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_epoch_end">on_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called when either of train/val/test epoch ends.</p>
<h4 id="on_epoch_start">on_epoch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_epoch_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called when either of train/val/test epoch begins.</p>
<h4 id="on_fit_end">on_fit_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_fit_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the very end of fit.</p>
<p>If on DDP it is called on every process</p>
<h4 id="on_fit_start">on_fit_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_fit_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the very beginning of fit.</p>
<p>If on DDP it is called on every process</p>
<h4 id="on_hpc_load">on_hpc_load</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_hpc_load</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">checkpoint</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Hook to do whatever you need right before Slurm manager loads the model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkpoint</td>
<td>None</td>
<td>A dictionary with variables from the checkpoint.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_hpc_save">on_hpc_save</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_hpc_save</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">checkpoint</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Hook to do whatever you need right before Slurm manager saves the model.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>checkpoint</td>
<td>None</td>
<td>A dictionary in which you can save variables to save in a checkpoint.</td>
<td></td>
</tr>
<tr>
<td>Contents need to be pickleable.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="on_load_checkpoint">on_load_checkpoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_load_checkpoint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">checkpoint</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called by Lightning to restore your model.
If you saved something with :meth:<code>on_save_checkpoint</code> this is your chance to restore this.</p>
<p>Args:
    checkpoint: Loaded checkpoint</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def on_load_checkpoint(self, checkpoint):
    # 99% of the time you don&#39;t need to implement this method
    self.something_cool_i_want_to_save = checkpoint[&#39;something_cool_i_want_to_save&#39;]
</code></pre></div>
<p>Note:
    Lightning auto-restores global step, epoch, and train state including amp scaling.
    There is no need for you to restore anything regarding training.</p>
<h4 id="on_post_move_to_device">on_post_move_to_device</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_post_move_to_device</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the <code>parameter_validation</code> decorator after</p>
<h4 id="on_predict_batch_end">on_predict_batch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_batch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the predict loop after the batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>The outputs of predict_step_end(test_step(x))</td>
<td>None</td>
</tr>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the test DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>the index of the dataloader</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_predict_batch_start">on_predict_batch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_batch_start</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the predict loop before anything happens for that batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the test DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>the index of the dataloader</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_predict_dataloader">on_predict_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called before requesting the predict dataloader.</p>
<h4 id="on_predict_end">on_predict_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of predicting.</p>
<h4 id="on_predict_epoch_end">on_predict_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">results</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of predicting.</p>
<h4 id="on_predict_epoch_start">on_predict_epoch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_epoch_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of predicting.</p>
<h4 id="on_predict_model_eval">on_predict_model_eval</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_model_eval</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets the model to eval during the predict loop.</p>
<h4 id="on_predict_start">on_predict_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_predict_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of predicting.</p>
<h4 id="on_pretrain_routine_end">on_pretrain_routine_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_pretrain_routine_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of the pretrain routine (between fit and train start).</p>
<ul>
<li>fit</li>
<li>pretrain_routine start</li>
<li>pretrain_routine end</li>
<li>training_start</li>
</ul>
<h4 id="on_pretrain_routine_start">on_pretrain_routine_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_pretrain_routine_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of the pretrain routine (between fit and train start).</p>
<ul>
<li>fit</li>
<li>pretrain_routine start</li>
<li>pretrain_routine end</li>
<li>training_start</li>
</ul>
<h4 id="on_save_checkpoint">on_save_checkpoint</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_save_checkpoint</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">checkpoint</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called by Lightning when saving a checkpoint to give you a chance to store anything
else you might want to save.</p>
<p>Args:
    checkpoint: The full checkpoint dictionary before it gets dumped to a file.
        Implementations of this hook can insert additional data into this dictionary.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def on_save_checkpoint(self, checkpoint):
    # 99% of use cases you don&#39;t need to implement this method
    checkpoint[&#39;something_cool_i_want_to_save&#39;] = my_cool_pickable_object
</code></pre></div>
<p>Note:
    Lightning saves all aspects of training (epoch, global step, etc...)
    including amp scaling.
    There is no need for you to store anything about training.</p>
<h4 id="on_test_batch_end">on_test_batch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_batch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">],</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the test loop after the batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>The outputs of test_step_end(test_step(x))</td>
<td>None</td>
</tr>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the test DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>the index of the dataloader</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_test_batch_start">on_test_batch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_batch_start</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the test loop before anything happens for that batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the test DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>the index of the dataloader</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_test_dataloader">on_test_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called before requesting the test dataloader.</p>
<h4 id="on_test_end">on_test_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of testing.</p>
<h4 id="on_test_epoch_end">on_test_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the test loop at the very end of the epoch.</p>
<h4 id="on_test_epoch_start">on_test_epoch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_epoch_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the test loop at the very beginning of the epoch.</p>
<h4 id="on_test_model_eval">on_test_model_eval</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_model_eval</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets the model to eval during the test loop.</p>
<h4 id="on_test_model_train">on_test_model_train</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_model_train</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets the model to train during the test loop.</p>
<h4 id="on_test_start">on_test_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_test_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of testing.</p>
<h4 id="on_train_batch_end">on_train_batch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_batch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">unused</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the training loop after the batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>The outputs of training_step_end(training_step(x))</td>
<td>None</td>
</tr>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the training DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>unused</td>
<td>None</td>
<td>Deprecated argument. Will be removed in v1.7.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_train_batch_start">on_train_batch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_batch_start</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">unused</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the training loop before anything happens for that batch.</p>
<p>If you return -1 here, you will skip training for the rest of the current epoch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the training DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>unused</td>
<td>None</td>
<td>Deprecated argument. Will be removed in v1.7.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_train_dataloader">on_train_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called before requesting the train dataloader.</p>
<h4 id="on_train_end">on_train_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of training before logger experiment is closed.</p>
<h4 id="on_train_epoch_end">on_train_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the training loop at the very end of the epoch.</p>
<p>To access all batch outputs at the end of the epoch, either:</p>
<ol>
<li>Implement <code>training_epoch_end</code> in the LightningModule OR</li>
<li>Cache data across steps on the attribute(s) of the <code>LightningModule</code> and access them in this hook</li>
</ol>
<h4 id="on_train_epoch_start">on_train_epoch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_epoch_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the training loop at the very beginning of the epoch.</p>
<h4 id="on_train_start">on_train_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_train_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of training after sanity check.</p>
<h4 id="on_val_dataloader">on_val_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_val_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called before requesting the val dataloader.</p>
<h4 id="on_validation_batch_end">on_validation_batch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_batch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">],</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the validation loop after the batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>The outputs of validation_step_end(validation_step(x))</td>
<td>None</td>
</tr>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the validation DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>the index of the dataloader</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_validation_batch_start">on_validation_batch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_batch_start</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the validation loop before anything happens for that batch.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>The batched data as it is returned by the validation DataLoader.</td>
<td>None</td>
</tr>
<tr>
<td>batch_idx</td>
<td>None</td>
<td>the index of the batch</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>the index of the dataloader</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="on_validation_end">on_validation_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of validation.</p>
<h4 id="on_validation_epoch_end">on_validation_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the validation loop at the very end of the epoch.</p>
<h4 id="on_validation_epoch_start">on_validation_epoch_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_epoch_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called in the validation loop at the very beginning of the epoch.</p>
<h4 id="on_validation_model_eval">on_validation_model_eval</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_model_eval</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets the model to eval during the val loop.</p>
<h4 id="on_validation_model_train">on_validation_model_train</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_model_train</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets the model to train during the val loop.</p>
<h4 id="on_validation_start">on_validation_start</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">on_validation_start</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of validation.</p>
<h4 id="optimizer_step">optimizer_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">optimizer_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="n">pytorch_lightning</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">LightningOptimizer</span><span class="p">],</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">optimizer_closure</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[],</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">on_tpu</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">using_native_amp</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">using_lbfgs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Override this method to adjust the default way the
:class:<code>~pytorch_lightning.trainer.trainer.Trainer</code> calls each optimizer.
By default, Lightning calls <code>step()</code> and <code>zero_grad()</code> as shown in the example
once per optimizer. This method (and <code>zero_grad()</code>) won't be called during the
accumulation phase when <code>Trainer(accumulate_grad_batches != 1)</code>.</p>
<p>Args:
    epoch: Current epoch
    batch_idx: Index of current batch
    optimizer: A PyTorch optimizer
    optimizer_idx: If you used multiple optimizers, this indexes into that list.
    optimizer_closure: Closure for all optimizers. This closure must be executed as it includes the
        calls to <code>training_step()</code>, <code>optimizer.zero_grad()</code>, and <code>backward()</code>.
    on_tpu: <code>True</code> if TPU backward is required
    using_native_amp: <code>True</code> if using native amp
    using_lbfgs: True if the matching optimizer is :class:<code>torch.optim.LBFGS</code></p>
<p>Examples::</p>
<div class="highlight"><pre><span></span><code># DEFAULT
def optimizer_step(self, epoch, batch_idx, optimizer, optimizer_idx,
                   optimizer_closure, on_tpu, using_native_amp, using_lbfgs):
    optimizer.step(closure=optimizer_closure)

# Alternating schedule for optimizer steps (i.e.: GANs)
def optimizer_step(self, epoch, batch_idx, optimizer, optimizer_idx,
                   optimizer_closure, on_tpu, using_native_amp, using_lbfgs):
    # update generator opt every step
    if optimizer_idx == 0:
        optimizer.step(closure=optimizer_closure)

    # update discriminator opt every 2 steps
    if optimizer_idx == 1:
        if (batch_idx + 1) % 2 == 0 :
            optimizer.step(closure=optimizer_closure)
        else:
            # call the closure by itself to run `training_step` + `backward` without an optimizer step
            optimizer_closure()

    # ...
    # add as many optimizers as you want
</code></pre></div>
<p>Here's another example showing how to use this for more advanced things such as
learning rate warm-up:</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># learning rate warm-up
def optimizer_step(
    self,
    epoch,
    batch_idx,
    optimizer,
    optimizer_idx,
    optimizer_closure,
    on_tpu,
    using_native_amp,
    using_lbfgs,
):
    # warm up lr
    if self.trainer.global_step &lt; 500:
        lr_scale = min(1.0, float(self.trainer.global_step + 1) / 500.0)
        for pg in optimizer.param_groups:
            pg[&quot;lr&quot;] = lr_scale * self.learning_rate

    # update params
    optimizer.step(closure=optimizer_closure)
</code></pre></div>
<h4 id="optimizer_zero_grad">optimizer_zero_grad</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">optimizer_zero_grad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">epoch</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span>
</code></pre></div>
<p>Override this method to change the default behaviour of <code>optimizer.zero_grad()</code>.</p>
<p>Args:
    epoch: Current epoch
    batch_idx: Index of current batch
    optimizer: A PyTorch optimizer
    optimizer_idx: If you used multiple optimizers this indexes into that list.</p>
<p>Examples::</p>
<div class="highlight"><pre><span></span><code># DEFAULT
def optimizer_zero_grad(self, epoch, batch_idx, optimizer, optimizer_idx):
    optimizer.zero_grad()

# Set gradients to `None` instead of zero to improve performance.
def optimizer_zero_grad(self, epoch, batch_idx, optimizer, optimizer_idx):
    optimizer.zero_grad(set_to_none=True)
</code></pre></div>
<p>See :meth:<code>torch.optim.Optimizer.zero_grad</code> for the explanation of the above example.</p>
<h4 id="optimizers">optimizers</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">optimizers</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">use_pl_optimizer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="n">pytorch_lightning</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">LightningOptimizer</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">pytorch_lightning</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">LightningOptimizer</span><span class="p">]]</span>
</code></pre></div>
<p>Returns the optimizer(s) that are being used during training. Useful for manual optimization.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>use_pl_optimizer</td>
<td>None</td>
<td>If <code>True</code>, will wrap the optimizer(s) in a</td>
<td></td>
</tr>
<tr>
<td>:class:<code>~pytorch_lightning.core.optimizer.LightningOptimizer</code> for automatic handling of precision and</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>profiling.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A single optimizer, or a list of optimizers in case multiple ones are present.</td>
</tr>
</tbody>
</table>
<h4 id="parameters_1">parameters</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">parameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">recurse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span>
</code></pre></div>
<p>Returns an iterator over module parameters.</p>
<p>This is typically passed to an optimizer.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>recurse</td>
<td>bool</td>
<td>if True, then yields parameters of this module</td>
<td></td>
</tr>
<tr>
<td>and all submodules. Otherwise, yields only parameters that</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are direct members of this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Yields:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameter</td>
<td>module parameter</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; for param in model.parameters():
&gt;&gt;&gt;     print(type(param), param.size())
&lt;class &#39;torch.Tensor&#39;&gt; (20L,)
&lt;class &#39;torch.Tensor&#39;&gt; (20L, 1L, 5L, 5L) |
</code></pre></div>
<h4 id="predict_dataloader">predict_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">predict_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]]</span>
</code></pre></div>
<p>Implement one or multiple PyTorch DataLoaders for prediction.</p>
<p>It's recommended that all data downloads and preparation happen in :meth:<code>prepare_data</code>.</p>
<ul>
<li>:meth:<code>~pytorch_lightning.trainer.Trainer.fit</code></li>
<li>...</li>
<li>:meth:<code>prepare_data</code></li>
<li>:meth:<code>train_dataloader</code></li>
<li>:meth:<code>val_dataloader</code></li>
<li>:meth:<code>test_dataloader</code></li>
</ul>
<p>Note:
    Lightning adds the correct sampler for distributed and arbitrary hardware
    There is no need to set it yourself.</p>
<p>Return:
    A :class:<code>torch.utils.data.DataLoader</code> or a sequence of them specifying prediction samples.</p>
<p>Note:
    In the case where you return multiple prediction dataloaders, the :meth:<code>predict</code>
    will have an argument <code>dataloader_idx</code> which matches the order here.</p>
<h4 id="predict_step">predict_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">predict_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">batch_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span>
</code></pre></div>
<p>Step function called during :meth:<code>~pytorch_lightning.trainer.trainer.Trainer.predict</code>. By default, it
calls :meth:<code>~pytorch_lightning.core.lightning.LightningModule.forward</code>. Override to add any processing
logic.</p>
<p>The :meth:<code>~pytorch_lightning.core.lightning.LightningModule.predict_step</code> is used
to scale inference on multi-devices.</p>
<p>To prevent an OOM error, it is possible to use :class:<code>~pytorch_lightning.callbacks.BasePredictionWriter</code>
callback to write the predictions to disk or database after each batch or on epoch end.</p>
<p>The :class:<code>~pytorch_lightning.callbacks.BasePredictionWriter</code> should be used while using a spawn
based accelerator. This happens for <code>Trainer(strategy="ddp_spawn")</code>
or training on 8 TPU cores with <code>Trainer(tpu_cores=8)</code> as predictions won't be returned.</p>
<p>Example ::</p>
<div class="highlight"><pre><span></span><code>class MyModel(LightningModule):

    def predicts_step(self, batch, batch_idx, dataloader_idx):
        return self(batch)

dm = ...
model = MyModel()
trainer = Trainer(gpus=2)
predictions = trainer.predict(model, dm)
</code></pre></div>
<p>Args:
    batch: Current batch
    batch_idx: Index of current batch
    dataloader_idx: Index of the current dataloader</p>
<p>Return:
    Predicted output</p>
<h4 id="prepare_data">prepare_data</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">prepare_data</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Use this to download and prepare data.</p>
<p>.. warning:: DO NOT set state to the model (use <code>setup</code> instead)
    since this is NOT called on every GPU in DDP/TPU</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def prepare_data(self):
    # good
    download_data()
    tokenize()
    etc()

    # bad
    self.split = data_split
    self.some_state = some_other_state()
</code></pre></div>
<p>In DDP prepare_data can be called in two ways (using Trainer(prepare_data_per_node)):</p>
<ol>
<li>Once per node. This is the default and is only called on LOCAL_RANK=0.</li>
<li>Once in total. Only called on GLOBAL_RANK=0.</li>
</ol>
<p>Example::</p>
<div class="highlight"><pre><span></span><code># DEFAULT
# called once per node on LOCAL_RANK=0 of that node
Trainer(prepare_data_per_node=True)

# call on GLOBAL_RANK=0 (great for shared file systems)
Trainer(prepare_data_per_node=False)
</code></pre></div>
<p>Note:
    Setting <code>prepare_data_per_node</code> with the trainer flag is deprecated and will be removed in v1.7.0.
    Please set <code>prepare_data_per_node</code> in LightningDataModule or LightningModule directly instead.</p>
<p>This is called before requesting the dataloaders:</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code>model.prepare_data()
initialize_distributed()
model.setup(stage)
model.train_dataloader()
model.val_dataloader()
model.test_dataloader()
</code></pre></div>
<h4 id="print">print</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">print</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Prints only from process 0. Use this in any distributed mode to log only once.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>*args</td>
<td>None</td>
<td>The thing to print. The same as for Python's built-in print function.</td>
<td>None</td>
</tr>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>The same as for Python's built-in print function.</td>
<td></td>
</tr>
<tr>
<td>Example::</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>def forward</td>
<td>self, x</td>
<td>self.print(x, 'in forward')</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="register_backward_hook_1">register_backward_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_backward_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">),</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a backward hook on the module.</p>
<p>This function is deprecated in favor of :meth:<code>~torch.nn.Module.register_full_backward_hook</code> and
the behavior of this function will change in future versions.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>:class:<code>torch.utils.hooks.RemovableHandle</code>:</td>
</tr>
<tr>
<td>a handle that can be used to remove the added hook by calling</td>
<td></td>
</tr>
<tr>
<td><code>handle.remove()</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="register_buffer_1">register_buffer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_buffer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">tensor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span>
    <span class="n">persistent</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Adds a buffer to the module.</p>
<p>This is typically used to register a buffer that should not to be
considered a model parameter. For example, BatchNorm's <code>running_mean</code>
is not a parameter, but is part of the module's state. Buffers, by
default, are persistent and will be saved alongside parameters. This
behavior can be changed by setting :attr:<code>persistent</code> to <code>False</code>. The
only difference between a persistent buffer and a non-persistent buffer
is that the latter will not be a part of this module's
:attr:<code>state_dict</code>.</p>
<p>Buffers can be accessed as attributes using given names.</p>
<p>Args:
    name (string): name of the buffer. The buffer can be accessed
        from this module using the given name
    tensor (Tensor or None): buffer to be registered. If <code>None</code>, then operations
        that run on buffers, such as :attr:<code>cuda</code>, are ignored. If <code>None</code>,
        the buffer is <strong>not</strong> included in the module's :attr:<code>state_dict</code>.
    persistent (bool): whether the buffer is part of this module's
        :attr:<code>state_dict</code>.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; self.register_buffer(&#39;running_mean&#39;, torch.zeros(num_features))
</code></pre></div>
<h4 id="register_forward_hook_1">register_forward_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_forward_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a forward hook on the module.</p>
<p>The hook will be called every time after :func:<code>forward</code> has computed an output.
It should have the following signature::</p>
<div class="highlight"><pre><span></span><code>hook(module, input, output) -&gt; None or modified output
</code></pre></div>
<p>The input contains only the positional arguments given to the module.
Keyword arguments won't be passed to the hooks and only to the <code>forward</code>.
The hook can modify the output. It can modify the input inplace but
it will not have effect on forward since this is called after</p>
<h4 id="register_forward_pre_hook_1">register_forward_pre_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_forward_pre_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a forward pre-hook on the module.</p>
<p>The hook will be called every time before :func:<code>forward</code> is invoked.
It should have the following signature::</p>
<div class="highlight"><pre><span></span><code>hook(module, input) -&gt; None or modified input
</code></pre></div>
<p>The input contains only the positional arguments given to the module.
Keyword arguments won't be passed to the hooks and only to the <code>forward</code>.
The hook can modify the input. User can either return a tuple or a
single modified value in the hook. We will wrap the value into a tuple
if a single value is returned(unless that value is already a tuple).</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>:class:<code>torch.utils.hooks.RemovableHandle</code>:</td>
</tr>
<tr>
<td>a handle that can be used to remove the added hook by calling</td>
<td></td>
</tr>
<tr>
<td><code>handle.remove()</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="register_full_backward_hook_1">register_full_backward_hook</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_full_backward_hook</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">hook</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ForwardRef</span><span class="p">(</span><span class="s1">&#39;Module&#39;</span><span class="p">),</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]],</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">hooks</span><span class="o">.</span><span class="n">RemovableHandle</span>
</code></pre></div>
<p>Registers a backward hook on the module.</p>
<p>The hook will be called every time the gradients with respect to module
inputs are computed. The hook should have the following signature::</p>
<div class="highlight"><pre><span></span><code>hook(module, grad_input, grad_output) -&gt; tuple(Tensor) or None
</code></pre></div>
<p>The :attr:<code>grad_input</code> and :attr:<code>grad_output</code> are tuples that contain the gradients
with respect to the inputs and outputs respectively. The hook should
not modify its arguments, but it can optionally return a new gradient with
respect to the input that will be used in place of :attr:<code>grad_input</code> in
subsequent computations. :attr:<code>grad_input</code> will only correspond to the inputs given
as positional arguments and all kwarg arguments are ignored. Entries
in :attr:<code>grad_input</code> and :attr:<code>grad_output</code> will be <code>None</code> for all non-Tensor
arguments.</p>
<p>For technical reasons, when this hook is applied to a Module, its forward function will
receive a view of each Tensor passed to the Module. Similarly the caller will receive a view
of each Tensor returned by the Module's forward function.</p>
<p>.. warning ::
    Modifying inputs or outputs inplace is not allowed when using backward hooks and
    will raise an error.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>:class:<code>torch.utils.hooks.RemovableHandle</code>:</td>
</tr>
<tr>
<td>a handle that can be used to remove the added hook by calling</td>
<td></td>
</tr>
<tr>
<td><code>handle.remove()</code></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="register_parameter_1">register_parameter</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">register_parameter</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">param</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">parameter</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Adds a parameter to the module.</p>
<p>The parameter can be accessed as an attribute using given name.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>string</td>
<td>name of the parameter. The parameter can be accessed</td>
<td></td>
</tr>
<tr>
<td>from this module using the given name</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>param</td>
<td>Parameter or None</td>
<td>parameter to be added to the module. If</td>
<td></td>
</tr>
<tr>
<td><code>None</code>, then operations that run on parameters, such as :attr:<code>cuda</code>,</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>are ignored. If <code>None</code>, the parameter is <strong>not</strong> included in the</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>module's :attr:<code>state_dict</code>.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="requires_grad__1">requires_grad_</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">requires_grad_</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">requires_grad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Change if autograd should record operations on parameters in this</p>
<p>module.</p>
<p>This method sets the parameters' :attr:<code>requires_grad</code> attributes
in-place.</p>
<p>This method is helpful for freezing part of the module for finetuning
or training parts of a model individually (e.g., GAN training).</p>
<p>See :ref:<code>locally-disable-grad-doc</code> for a comparison between
<code>.requires_grad_()</code> and several similar mechanisms that may be confused with it.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>requires_grad</td>
<td>bool</td>
<td>whether autograd should record operations on</td>
<td></td>
</tr>
<tr>
<td>parameters in this module. Default: <code>True</code>.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="save_hyperparameters">save_hyperparameters</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">save_hyperparameters</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="n">ignore</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">frame</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">frame</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">logger</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Save arguments to <code>hparams</code> attribute.</p>
<p>Args:
    args: single object of <code>dict</code>, <code>NameSpace</code> or <code>OmegaConf</code>
        or string names or arguments from class <code>__init__</code>
    ignore: an argument name or a list of argument names from
        class <code>__init__</code> to be ignored
    frame: a frame object. Default is None
    logger: Whether to send the hyperparameters to the logger. Default: True</p>
<p>Example::
    &gt;&gt;&gt; class ManuallyArgsModel(HyperparametersMixin):
    ...     def <strong>init</strong>(self, arg1, arg2, arg3):
    ...         super().<strong>init</strong>()
    ...         # manually assign arguments
    ...         self.save_hyperparameters('arg1', 'arg3')
    ...     def forward(self, <em>args, </em>*kwargs):
    ...         ...
    &gt;&gt;&gt; model = ManuallyArgsModel(1, 'abc', 3.14)
    &gt;&gt;&gt; model.hparams
    "arg1": 1
    "arg3": 3.14</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; class AutomaticArgsModel(HyperparametersMixin):
...     def __init__(self, arg1, arg2, arg3):
...         super().__init__()
...         # equivalent automatic
...         self.save_hyperparameters()
...     def forward(self, *args, **kwargs):
...         ...
&gt;&gt;&gt; model = AutomaticArgsModel(1, &#39;abc&#39;, 3.14)
&gt;&gt;&gt; model.hparams
&quot;arg1&quot;: 1
&quot;arg2&quot;: abc
&quot;arg3&quot;: 3.14

&gt;&gt;&gt; class SingleArgModel(HyperparametersMixin):
...     def __init__(self, params):
...         super().__init__()
...         # manually assign single argument
...         self.save_hyperparameters(params)
...     def forward(self, *args, **kwargs):
...         ...
&gt;&gt;&gt; model = SingleArgModel(Namespace(p1=1, p2=&#39;abc&#39;, p3=3.14))
&gt;&gt;&gt; model.hparams
&quot;p1&quot;: 1
&quot;p2&quot;: abc
&quot;p3&quot;: 3.14

&gt;&gt;&gt; class ManuallyArgsModel(HyperparametersMixin):
...     def __init__(self, arg1, arg2, arg3):
...         super().__init__()
...         # pass argument(s) to ignore as a string or in a list
...         self.save_hyperparameters(ignore=&#39;arg2&#39;)
...     def forward(self, *args, **kwargs):
...         ...
&gt;&gt;&gt; model = ManuallyArgsModel(1, &#39;abc&#39;, 3.14)
&gt;&gt;&gt; model.hparams
&quot;arg1&quot;: 1
&quot;arg3&quot;: 3.14
</code></pre></div>
<h4 id="set_extra_state_1">set_extra_state</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">set_extra_state</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">)</span>
</code></pre></div>
<p>This function is called from :func:<code>load_state_dict</code> to handle any extra state</p>
<p>found within the <code>state_dict</code>. Implement this function and a corresponding</p>
<h4 id="setup">setup</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">setup</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">stage</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the beginning of fit (train + validate), validate, test, and predict. This is a good hook when</p>
<p>you need to build models dynamically or adjust something about them. This hook is called on every process
when using DDP.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>stage</td>
<td>None</td>
<td>either <code>'fit'</code>, <code>'validate'</code>, <code>'test'</code>, or <code>'predict'</code></td>
<td></td>
</tr>
<tr>
<td>Example::</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>class LitModel</td>
<td>...</td>
<td>def <strong>init</strong>(self):</td>
<td></td>
</tr>
<tr>
<td>self.l1 = None</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>def prepare_data(self):
    download_data()
    tokenize()</p>
<div class="highlight"><pre><span></span><code># don&#39;t do this
self.something = else
</code></pre></div>
<p>def setup(stage):
    data = Load_data(...)
    self.l1 = nn.Linear(28, data.num_classes) | None |</p>
<h4 id="share_memory_1">share_memory</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">share_memory</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>See :meth:<code>torch.Tensor.share_memory_</code></p>
<h4 id="state_dict_1">state_dict</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">state_dict</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">destination</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">prefix</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
    <span class="n">keep_vars</span><span class="o">=</span><span class="kc">False</span>
<span class="p">)</span>
</code></pre></div>
<p>Returns a dictionary containing a whole state of the module.</p>
<p>Both parameters and persistent buffers (e.g. running averages) are
included. Keys are corresponding parameter and buffer names.
Parameters and buffers set to <code>None</code> are not included.</p>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>dict</td>
<td>a dictionary containing a whole state of the module</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; module.state_dict().keys()
[&#39;bias&#39;, &#39;weight&#39;] |
</code></pre></div>
<h4 id="summarize">summarize</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">summarize</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;top&#39;</span><span class="p">,</span>
    <span class="n">max_depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pytorch_lightning</span><span class="o">.</span><span class="n">utilities</span><span class="o">.</span><span class="n">model_summary</span><span class="o">.</span><span class="n">ModelSummary</span><span class="p">]</span>
</code></pre></div>
<p>Summarize this LightningModule.</p>
<p>.. deprecated:: v1.5
    This method was deprecated in v1.5 in favor of <code>pytorch_lightning.utilities.model_summary.summarize</code>
    and will be removed in v1.7.</p>
<p>Args:
    mode: Can be either <code>'top'</code> (summarize only direct submodules) or <code>'full'</code> (summarize all layers).</p>
<div class="highlight"><pre><span></span><code>    .. deprecated:: v1.4
        This parameter was deprecated in v1.4 in favor of `max_depth` and will be removed in v1.6.

max_depth: The maximum depth of layer nesting that the summary will include. A value of 0 turns the
    layer summary off. Default: 1.
</code></pre></div>
<p>Return:
    The model summary object</p>
<h4 id="tbptt_split_batch">tbptt_split_batch</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">tbptt_split_batch</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">split_size</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span>
</code></pre></div>
<p>When using truncated backpropagation through time, each batch must be split along the
time dimension. Lightning handles this by default, but for custom behavior override
this function.</p>
<p>Args:
    batch: Current batch
    split_size: The size of the split</p>
<p>Return:
    List of batch splits. Each split will be passed to :meth:<code>training_step</code> to enable truncated
    back propagation through time. The default implementation splits root level Tensors and
    Sequences at dim=1 (i.e. time dim). It assumes that each time dim is the same length.</p>
<p>Examples::</p>
<div class="highlight"><pre><span></span><code>def tbptt_split_batch(self, batch, split_size):
    splits = []
    for t in range(0, time_dims[0], split_size):
        batch_split = []
        for i, x in enumerate(batch):
            if isinstance(x, torch.Tensor):
                split_x = x[:, t:t + split_size]
            elif isinstance(x, collections.Sequence):
                split_x = [None] * len(x)
                for batch_idx in range(len(x)):
                  split_x[batch_idx] = x[batch_idx][t:t + split_size]
            batch_split.append(split_x)
        splits.append(batch_split)
    return splits
</code></pre></div>
<p>Note:
    Called in the training loop after
    :meth:<code>~pytorch_lightning.callbacks.base.Callback.on_batch_start</code>
    if :paramref:<code>~pytorch_lightning.core.lightning.LightningModule.truncated_bptt_steps</code> &gt; 0.
    Each returned batch split is passed separately to :meth:<code>training_step</code>.</p>
<h4 id="teardown">teardown</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">teardown</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">stage</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of fit (train + validate), validate, test, predict, or tune.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>stage</td>
<td>None</td>
<td>either <code>'fit'</code>, <code>'validate'</code>, <code>'test'</code>, or <code>'predict'</code></td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="test_dataloader">test_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]]</span>
</code></pre></div>
<p>Implement one or multiple PyTorch DataLoaders for testing.</p>
<p>The dataloader you return will not be reloaded unless you set</p>
<h4 id="test_epoch_end">test_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of a test epoch with the output of all test steps.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># the pseudocode for these calls
test_outs = []
for test_batch in test_data:
    out = test_step(test_batch)
    test_outs.append(out)
test_epoch_end(test_outs)
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>List of outputs you defined in :meth:<code>test_step_end</code>, or if there</td>
<td></td>
</tr>
<tr>
<td>are multiple dataloaders, a list containing a list of outputs for each dataloader</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Return: | None |
| None</p>
<p>Note | None |  | None |
| If you didn't define a  | None | meth:<code>test_step</code>, this won't be called. | None |</p>
<h4 id="test_step">test_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">]</span>
</code></pre></div>
<p>Operates on a single batch of data from the test set.
In this step you'd normally generate examples or calculate anything of interest
such as accuracy.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># the pseudocode for these calls
test_outs = []
for test_batch in test_data:
    out = test_step(test_batch)
    test_outs.append(out)
test_epoch_end(test_outs)
</code></pre></div>
<p>Args:
    batch (:class:<code>~torch.Tensor</code> | (:class:<code>~torch.Tensor</code>, ...) | [:class:<code>~torch.Tensor</code>, ...]):
        The output of your :class:<code>~torch.utils.data.DataLoader</code>. A tensor, tuple or list.
    batch_idx (int): The index of this batch.
    dataloader_idx (int): The index of the dataloader that produced this batch
        (only if multiple test dataloaders used).</p>
<p>Return:
   Any of.</p>
<div class="highlight"><pre><span></span><code>- Any object or value
- ``None`` - Testing will skip to the next batch
</code></pre></div>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># if you have one test dataloader:
def test_step(self, batch, batch_idx):
    ...

# if you have multiple test dataloaders:
def test_step(self, batch, batch_idx, dataloader_idx):
    ...
</code></pre></div>
<p>Examples::</p>
<div class="highlight"><pre><span></span><code># CASE 1: A single test dataset
def test_step(self, batch, batch_idx):
    x, y = batch

    # implement your own
    out = self(x)
    loss = self.loss(out, y)

    # log 6 example images
    # or generated text... or whatever
    sample_imgs = x[:6]
    grid = torchvision.utils.make_grid(sample_imgs)
    self.logger.experiment.add_image(&#39;example_images&#39;, grid, 0)

    # calculate acc
    labels_hat = torch.argmax(out, dim=1)
    test_acc = torch.sum(y == labels_hat).item() / (len(y) * 1.0)

    # log the outputs!
    self.log_dict({&#39;test_loss&#39;: loss, &#39;test_acc&#39;: test_acc})
</code></pre></div>
<p>If you pass in multiple test dataloaders, :meth:<code>test_step</code> will have an additional argument.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># CASE 2: multiple test dataloaders
def test_step(self, batch, batch_idx, dataloader_idx):
    # dataloader_idx tells you which dataset this is.
    ...
</code></pre></div>
<p>Note:
    If you don't need to test you don't need to implement this method.</p>
<p>Note:
    When the :meth:<code>test_step</code> is called, the model has been put in eval mode and
    PyTorch gradients have been disabled. At the end of the test epoch, the model goes back
    to training mode and gradients are enabled.</p>
<h4 id="test_step_end">test_step_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">test_step_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">]</span>
</code></pre></div>
<p>Use this when testing with dp or ddp2 because :meth:<code>test_step</code> will operate on only part of the batch.
However, this is still optional and only needed for things like softmax or NCE loss.</p>
<p>Note:
    If you later switch to ddp or some other mode, this will still be called
    so that you don't have to change your code.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># pseudocode
sub_batches = split_batches_for_dp(batch)
batch_parts_outputs = [test_step(sub_batch) for sub_batch in sub_batches]
test_step_end(batch_parts_outputs)
</code></pre></div>
<p>Args:
    batch_parts_outputs: What you return in :meth:<code>test_step</code> for each batch part.</p>
<p>Return:
    None or anything</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># WITHOUT test_step_end
# if used in DP or DDP2, this batch is 1/num_gpus large
def test_step(self, batch, batch_idx):
    # batch is 1/num_gpus big
    x, y = batch

    out = self(x)
    loss = self.softmax(out)
    self.log(&quot;test_loss&quot;, loss)

# --------------
# with test_step_end to do softmax over the full batch
def test_step(self, batch, batch_idx):
    # batch is 1/num_gpus big
    x, y = batch

    out = self.encoder(x)
    return out

def test_step_end(self, output_results):
    # this out is now the full size of the batch
    all_test_step_outs = output_results.out
    loss = nce_loss(all_test_step_outs)
    self.log(&quot;test_loss&quot;, loss)
</code></pre></div>
<p>See Also:
    See the :ref:<code>advanced/multi_gpu:Multi-GPU training</code> guide for more details.</p>
<h4 id="to_1">to</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Moves and/or casts the parameters and buffers.</p>
<p>This can be called as
.. function:: to(device=None, dtype=None, non_blocking=False)
.. function:: to(dtype, non_blocking=False)
.. function:: to(tensor, non_blocking=False)
Its signature is similar to :meth:<code>torch.Tensor.to</code>, but only accepts
floating point desired :attr:<code>dtype</code> s. In addition, this method will
only cast the floating point parameters and buffers to :attr:<code>dtype</code>
(if given). The integral parameters and buffers will be moved
:attr:<code>device</code>, if that is given, but with dtypes unchanged. When
:attr:<code>non_blocking</code> is set, it tries to convert/move asynchronously
with respect to the host if possible, e.g., moving CPU Tensors with
pinned memory to CUDA devices.
See below for examples.</p>
<p>Note:
    This method modifies the module in-place.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device</td>
<td>None</td>
<td>the desired device of the parameters</td>
<td></td>
</tr>
<tr>
<td>and buffers in this module</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>dtype</td>
<td>None</td>
<td>the desired floating point type of</td>
<td></td>
</tr>
<tr>
<td>the floating point parameters and buffers in this module</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>tensor</td>
<td>None</td>
<td>Tensor whose dtype and device are the desired</td>
<td></td>
</tr>
<tr>
<td>dtype and device for all parameters and buffers in this module</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
<tr>
<td>Example::</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; class ExampleModule(DeviceDtypeModuleMixin):</td>
<td></td>
</tr>
<tr>
<td>...     def <strong>init</strong>(self, weight: torch.Tensor):</td>
<td></td>
</tr>
<tr>
<td>...         super().<strong>init</strong>()</td>
<td></td>
</tr>
<tr>
<td>...         self.register_buffer('weight', weight)</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; _ = torch.manual_seed(0)</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module = ExampleModule(torch.rand(3, 4))</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.weight #doctest: +ELLIPSIS</td>
<td></td>
</tr>
<tr>
<td>tensor([[...]])</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.to(torch.double)</td>
<td></td>
</tr>
<tr>
<td>ExampleModule()</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.weight #doctest: +ELLIPSIS</td>
<td></td>
</tr>
<tr>
<td>tensor([[...]], dtype=torch.float64)</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; cpu = torch.device('cpu')</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.to(cpu, dtype=torch.half, non_blocking=True)</td>
<td></td>
</tr>
<tr>
<td>ExampleModule()</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.weight #doctest: +ELLIPSIS</td>
<td></td>
</tr>
<tr>
<td>tensor([[...]], dtype=torch.float16)</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.to(cpu)</td>
<td></td>
</tr>
<tr>
<td>ExampleModule()</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.weight #doctest: +ELLIPSIS</td>
<td></td>
</tr>
<tr>
<td>tensor([[...]], dtype=torch.float16)</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.device</td>
<td></td>
</tr>
<tr>
<td>device(type='cpu')</td>
<td></td>
</tr>
<tr>
<td>&gt;&gt;&gt; module.dtype</td>
<td></td>
</tr>
<tr>
<td>torch.float16</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="to_empty_1">to_empty</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to_empty</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Moves the parameters and buffers to the specified device without copying storage.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device (</td>
<td>None</td>
<td>class:<code>torch.device</code>): The desired device of the parameters</td>
<td></td>
</tr>
<tr>
<td>and buffers in this module.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="to_onnx">to_onnx</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to_onnx</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">file_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">],</span>
    <span class="n">input_sample</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span>
</code></pre></div>
<p>Saves the model in ONNX format.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>file_path</td>
<td>None</td>
<td>The path of the file the onnx model should be saved to.</td>
<td>None</td>
</tr>
<tr>
<td>input_sample</td>
<td>None</td>
<td>An input for tracing. Default: None (Use self.example_input_array)</td>
<td>None</td>
</tr>
<tr>
<td>**kwargs</td>
<td>None</td>
<td>Will be passed to torch.onnx.export function.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="to_torchscript">to_torchscript</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">to_torchscript</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">file_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;script&#39;</span><span class="p">,</span>
    <span class="n">example_inputs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">ScriptModule</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">_C</span><span class="o">.</span><span class="n">ScriptModule</span><span class="p">]]</span>
</code></pre></div>
<p>By default compiles the whole model to a :class:<code>~torch.jit.ScriptModule</code>. If you want to use tracing,
please provided the argument <code>method='trace'</code> and make sure that either the <code>example_inputs</code> argument is
provided, or the model has :attr:<code>example_input_array</code> set. If you would like to customize the modules that
are scripted you should override this method. In case you want to return multiple modules, we recommend
using a dictionary.</p>
<p>Args:
    file_path: Path where to save the torchscript. Default: None (no file saved).
    method: Whether to use TorchScript's script or trace method. Default: 'script'
    example_inputs: An input to be used to do tracing when method is set to 'trace'.
      Default: None (uses :attr:<code>example_input_array</code>)
    **kwargs: Additional arguments that will be passed to the :func:<code>torch.jit.script</code> or
      :func:<code>torch.jit.trace</code> function.</p>
<p>Note:
    - Requires the implementation of the
      :meth:<code>~pytorch_lightning.core.lightning.LightningModule.forward</code> method.
    - The exported script will be set to evaluation mode.
    - It is recommended that you install the latest supported version of PyTorch
      to use this feature without limitations. See also the :mod:<code>torch.jit</code>
      documentation for supported features.</p>
<p>Example:
    &gt;&gt;&gt; class SimpleModel(LightningModule):
    ...     def <strong>init</strong>(self):
    ...         super().<strong>init</strong>()
    ...         self.l1 = torch.nn.Linear(in_features=64, out_features=4)
    ...
    ...     def forward(self, x):
    ...         return torch.relu(self.l1(x.view(x.size(0), -1)))
    ...
    &gt;&gt;&gt; model = SimpleModel()
    &gt;&gt;&gt; torch.jit.save(model.to_torchscript(), "model.pt")  # doctest: +SKIP
    &gt;&gt;&gt; os.path.isfile("model.pt")  # doctest: +SKIP
    &gt;&gt;&gt; torch.jit.save(model.to_torchscript(file_path="model_trace.pt", method='trace', # doctest: +SKIP
    ...                                     example_inputs=torch.randn(1, 64)))  # doctest: +SKIP
    &gt;&gt;&gt; os.path.isfile("model_trace.pt")  # doctest: +SKIP
    True</p>
<p>Return:
    This LightningModule as a torchscript, regardless of whether <code>file_path</code> is
    defined or not.</p>
<h4 id="toggle_optimizer">toggle_optimizer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">toggle_optimizer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">optimizer</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">Optimizer</span><span class="p">,</span> <span class="n">pytorch_lightning</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">optimizer</span><span class="o">.</span><span class="n">LightningOptimizer</span><span class="p">],</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Makes sure only the gradients of the current optimizer's parameters are calculated in the training step</p>
<p>to prevent dangling gradients in multiple-optimizer setup.</p>
<p>This is only called automatically when automatic optimization is enabled and multiple optimizers are used.
It works with :meth:<code>untoggle_optimizer</code> to make sure <code>param_requires_grad_state</code> is properly reset.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>optimizer</td>
<td>None</td>
<td>The optimizer to toggle.</td>
<td>None</td>
</tr>
<tr>
<td>optimizer_idx</td>
<td>None</td>
<td>The index of the optimizer to toggle.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="train_1">train</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">train</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Sets the module in training mode.</p>
<p>This has any effect only on certain modules. See documentations of
particular modules for details of their behaviors in training/evaluation
mode, if they are affected, e.g. :class:<code>Dropout</code>, :class:<code>BatchNorm</code>,
etc.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>mode</td>
<td>bool</td>
<td>whether to set training mode (<code>True</code>) or evaluation</td>
<td></td>
</tr>
<tr>
<td>mode (<code>False</code>). Default: <code>True</code>.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="train_dataloader">train_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">train_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]]]</span>
</code></pre></div>
<p>Implement one or more PyTorch DataLoaders for training.</p>
<p>Return:
    A collection of :class:<code>torch.utils.data.DataLoader</code> specifying training samples.
    In the case of multiple dataloaders, please see this :ref:<code>page &lt;multiple-training-dataloaders&gt;</code>.</p>
<p>The dataloader you return will not be reloaded unless you set</p>
<h4 id="training_epoch_end">training_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">training_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of the training epoch with the outputs of all training steps. Use this in case you</p>
<p>need to do something with all the outputs returned by :meth:<code>training_step</code>.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># the pseudocode for these calls
train_outs = []
for train_batch in train_data:
    out = training_step(train_batch)
    train_outs.append(out)
training_epoch_end(train_outs)
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>List of outputs you defined in :meth:<code>training_step</code>.</td>
<td></td>
</tr>
<tr>
<td>If there are multiple optimizers, it is a list containing a list of outputs for each optimizer.</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>If using <code>truncated_bptt_steps &gt; 1</code>, each element is a list of outputs corresponding to the outputs</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>of each processed split batch.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Return: | None |
| None</p>
<p>Note | None |  | None |
| If this method is not overridden, this won't be called.</p>
<p>.. code-block | None | : python | None |
| def training_epoch_end | self, training_step_outputs | # do something with all training_step outputs
for out in training_step_outputs:
    ... | None |</p>
<h4 id="training_step">training_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">training_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">,</span>
    <span class="n">batch_idx_</span>
<span class="p">)</span>
</code></pre></div>
<p>Here you compute and return the training loss and some additional metrics for e.g.
the progress bar or logger.</p>
<p>Args:
    batch (:class:<code>~torch.Tensor</code> | (:class:<code>~torch.Tensor</code>, ...) | [:class:<code>~torch.Tensor</code>, ...]):
        The output of your :class:<code>~torch.utils.data.DataLoader</code>. A tensor, tuple or list.
    batch_idx (<code>int</code>): Integer displaying index of this batch
    optimizer_idx (<code>int</code>): When using multiple optimizers, this argument will also be present.
    hiddens (<code>Any</code>): Passed in if
        :paramref:<code>~pytorch_lightning.core.lightning.LightningModule.truncated_bptt_steps</code> &gt; 0.</p>
<p>Return:
    Any of.</p>
<div class="highlight"><pre><span></span><code>- :class:`~torch.Tensor` - The loss tensor
- ``dict`` - A dictionary. Can include any keys, but must include the key ``&#39;loss&#39;``
- ``None`` - Training will skip to the next batch. This is only for automatic optimization.
    This is not supported for multi-GPU, TPU, IPU, or DeepSpeed.
</code></pre></div>
<p>In this step you'd normally do the forward pass and calculate the loss for a batch.
You can also do fancier things like multiple forward passes or something model specific.</p>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def training_step(self, batch, batch_idx):
    x, y, z = batch
    out = self.encoder(x)
    loss = self.loss(out, x)
    return loss
</code></pre></div>
<p>If you define multiple optimizers, this step will be called with an additional
<code>optimizer_idx</code> parameter.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># Multiple optimizers (e.g.: GANs)
def training_step(self, batch, batch_idx, optimizer_idx):
    if optimizer_idx == 0:
        # do training_step with encoder
        ...
    if optimizer_idx == 1:
        # do training_step with decoder
        ...
</code></pre></div>
<p>If you add truncated back propagation through time you will also get an additional
argument with the hidden states of the previous step.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># Truncated back-propagation through time
def training_step(self, batch, batch_idx, hiddens):
    # hiddens are the hidden states from the previous truncated backprop step
    out, hiddens = self.lstm(data, hiddens)
    loss = ...
    return {&quot;loss&quot;: loss, &quot;hiddens&quot;: hiddens}
</code></pre></div>
<p>Note:
    The loss value shown in the progress bar is smoothed (averaged) over the last values,
    so it differs from the actual loss returned in train/validation step.</p>
<h4 id="training_step_end">training_step_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">training_step_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span>
</code></pre></div>
<p>Use this when training with dp or ddp2 because :meth:<code>training_step</code> will operate on only part of the</p>
<p>batch. However, this is still optional and only needed for things like softmax or NCE loss.</p>
<p>Note:
    If you later switch to ddp or some other mode, this will still be called
    so that you don't have to change your code</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># pseudocode
sub_batches = split_batches_for_dp(batch)
batch_parts_outputs = [training_step(sub_batch) for sub_batch in sub_batches]
training_step_end(batch_parts_outputs)
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch_parts_outputs</td>
<td>None</td>
<td>What you return in <code>training_step</code> for each batch part.</td>
<td></td>
</tr>
<tr>
<td>Return:</td>
<td>None</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Anything</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>When using dp/ddp2 distributed backends, only a portion of the batch is inside the training_step | None | .. code-block:: python | None |
| def training_step | self, batch, batch_idx | # batch is 1/num_gpus big
        x, y = batch</p>
<div class="highlight"><pre><span></span><code>    out = self(x)

    # softmax uses only a portion of the batch in the denominator
    loss = self.softmax(out)
    loss = nce_loss(loss)
    return loss
</code></pre></div>
<p>If you wish to do something with all the parts of the batch, then use this method to do it:</p>
<p>.. code-block:: python | None |
| def training_step | self, batch, batch_idx | # batch is 1/num_gpus big
x, y = batch</p>
<p>out = self.encoder(x)
return {"pred": out} | None |
| def training_step_end | self, training_step_outputs | gpu_0_pred = training_step_outputs[0]["pred"]
        gpu_1_pred = training_step_outputs[1]["pred"]
        gpu_n_pred = training_step_outputs[n]["pred"]</p>
<div class="highlight"><pre><span></span><code>    # this softmax now uses the full batch
    loss = nce_loss([gpu_0_pred, gpu_1_pred, gpu_n_pred])
    return loss
</code></pre></div>
<p>See Also: | None |
| See the  | None | ref:<code>advanced/multi_gpu:Multi-GPU training</code> guide for more details. | None |</p>
<h4 id="transfer_batch_to_device">transfer_batch_to_device</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">transfer_batch_to_device</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span>
    <span class="n">dataloader_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span>
</code></pre></div>
<p>Override this hook if your :class:<code>~torch.utils.data.DataLoader</code> returns tensors wrapped in a custom</p>
<p>data structure.</p>
<p>The data types listed below (and any arbitrary nesting of them) are supported out of the box:</p>
<ul>
<li>:class:<code>torch.Tensor</code> or anything that implements <code>.to(...)</code></li>
<li>:class:<code>list</code></li>
<li>:class:<code>dict</code></li>
<li>:class:<code>tuple</code></li>
<li>:class:<code>torchtext.data.batch.Batch</code></li>
</ul>
<p>For anything else, you need to define how the data is moved to the target device (CPU, GPU, TPU, ...).</p>
<p>Note:
    This hook should only transfer the data and not modify it, nor should it move the data to
    any other device than the one passed in as argument (unless you know what you are doing).
    To check the current state of execution of this hook you can use
    <code>self.trainer.training/testing/validating/predicting</code> so that you can
    add different logic as per your requirement.</p>
<p>Note:
    This hook only runs on single GPU training and DDP (no data-parallel).
    Data-Parallel support will come in near future.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>batch</td>
<td>None</td>
<td>A batch of data that needs to be transferred to a new device.</td>
<td>None</td>
</tr>
<tr>
<td>device</td>
<td>None</td>
<td>The target device as defined in PyTorch.</td>
<td>None</td>
</tr>
<tr>
<td>dataloader_idx</td>
<td>None</td>
<td>The index of the dataloader to which the batch belongs.</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>A reference to the data on the new device.</td>
</tr>
</tbody>
</table>
<p>Example::</p>
<div class="highlight"><pre><span></span><code>def transfer_batch_to_device(self, batch, device, dataloader_idx):
    if isinstance(batch, CustomBatch):
        # move all tensors in your custom data structure to the device
        batch.samples = batch.samples.to(device)
        batch.targets = batch.targets.to(device)
    elif dataloader_idx == 0:
        # skip device transfer for the first dataloader or anything you wish
        pass
    else:
        batch = super().transfer_batch_to_device(data, device)
    return batch |
</code></pre></div>
<p><strong>Raises:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>MisconfigurationException</td>
<td>If using data-parallel, <code>Trainer(strategy='dp')</code>.</td>
</tr>
</tbody>
</table>
<p>See Also: |
| -  | meth:<code>move_data_to_device</code> |
| -  | meth:<code>apply_to_collection</code> |</p>
<h4 id="type_1">type</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">type</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">dst_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DeviceDtypeModuleMixin&#39;</span>
</code></pre></div>
<p>Casts all parameters and buffers to :attr:<code>dst_type</code>.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>dst_type</td>
<td>type or string</td>
<td>the desired type</td>
<td>None</td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="unfreeze">unfreeze</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">unfreeze</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Unfreeze all parameters for training.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code>model = MyLightningModule(...)
model.unfreeze()
</code></pre></div>
<h4 id="untoggle_optimizer">untoggle_optimizer</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">untoggle_optimizer</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">optimizer_idx</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Resets the state of required gradients that were toggled with :meth:<code>toggle_optimizer</code>.</p>
<p>This is only called automatically when automatic optimization is enabled and multiple optimizers are used.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>optimizer_idx</td>
<td>None</td>
<td>The index of the optimizer to untoggle.</td>
<td>None</td>
</tr>
</tbody>
</table>
<h4 id="val_dataloader">val_dataloader</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">val_dataloader</span><span class="p">(</span>
    <span class="bp">self</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dataloader</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">]]</span>
</code></pre></div>
<p>Implement one or multiple PyTorch DataLoaders for validation.</p>
<p>The dataloader you return will not be reloaded unless you set</p>
<h4 id="validation_epoch_end">validation_epoch_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">validation_epoch_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">outputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Called at the end of the validation epoch with the outputs of all validation steps.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># the pseudocode for these calls
val_outs = []
for val_batch in val_data:
    out = validation_step(val_batch)
    val_outs.append(out)
validation_epoch_end(val_outs)
</code></pre></div>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>outputs</td>
<td>None</td>
<td>List of outputs you defined in :meth:<code>validation_step</code>, or if there</td>
<td></td>
</tr>
<tr>
<td>are multiple dataloaders, a list containing a list of outputs for each dataloader.</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Return: | None |
| None</p>
<p>Note | None |  | None |
| If you didn't define a  | None | meth:<code>validation_step</code>, this won't be called. | None |</p>
<h4 id="validation_step">validation_step</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">validation_step</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">,</span>
    <span class="n">batch_idx_</span>
<span class="p">)</span>
</code></pre></div>
<p>Operates on a single batch of data from the validation set.
In this step you'd might generate examples or calculate anything of interest like accuracy.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># the pseudocode for these calls
val_outs = []
for val_batch in val_data:
    out = validation_step(val_batch)
    val_outs.append(out)
validation_epoch_end(val_outs)
</code></pre></div>
<p>Args:
    batch (:class:<code>~torch.Tensor</code> | (:class:<code>~torch.Tensor</code>, ...) | [:class:<code>~torch.Tensor</code>, ...]):
        The output of your :class:<code>~torch.utils.data.DataLoader</code>. A tensor, tuple or list.
    batch_idx (int): The index of this batch
    dataloader_idx (int): The index of the dataloader that produced this batch
        (only if multiple val dataloaders used)</p>
<p>Return:
    - Any object or value
    - <code>None</code> - Validation will skip to the next batch</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># pseudocode of order
val_outs = []
for val_batch in val_data:
    out = validation_step(val_batch)
    if defined(&quot;validation_step_end&quot;):
        out = validation_step_end(out)
    val_outs.append(out)
val_outs = validation_epoch_end(val_outs)
</code></pre></div>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># if you have one val dataloader:
def validation_step(self, batch, batch_idx):
    ...

# if you have multiple val dataloaders:
def validation_step(self, batch, batch_idx, dataloader_idx):
    ...
</code></pre></div>
<p>Examples::</p>
<div class="highlight"><pre><span></span><code># CASE 1: A single validation dataset
def validation_step(self, batch, batch_idx):
    x, y = batch

    # implement your own
    out = self(x)
    loss = self.loss(out, y)

    # log 6 example images
    # or generated text... or whatever
    sample_imgs = x[:6]
    grid = torchvision.utils.make_grid(sample_imgs)
    self.logger.experiment.add_image(&#39;example_images&#39;, grid, 0)

    # calculate acc
    labels_hat = torch.argmax(out, dim=1)
    val_acc = torch.sum(y == labels_hat).item() / (len(y) * 1.0)

    # log the outputs!
    self.log_dict({&#39;val_loss&#39;: loss, &#39;val_acc&#39;: val_acc})
</code></pre></div>
<p>If you pass in multiple val dataloaders, :meth:<code>validation_step</code> will have an additional argument.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># CASE 2: multiple validation dataloaders
def validation_step(self, batch, batch_idx, dataloader_idx):
    # dataloader_idx tells you which dataset this is.
    ...
</code></pre></div>
<p>Note:
    If you don't need to validate you don't need to implement this method.</p>
<p>Note:
    When the :meth:<code>validation_step</code> is called, the model has been put in eval mode
    and PyTorch gradients have been disabled. At the end of validation,
    the model goes back to training mode and gradients are enabled.</p>
<h4 id="validation_step_end">validation_step_end</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">validation_step_end</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">NoneType</span><span class="p">]</span>
</code></pre></div>
<p>Use this when validating with dp or ddp2 because :meth:<code>validation_step</code> will operate on only part of
the batch. However, this is still optional and only needed for things like softmax or NCE loss.</p>
<p>Note:
    If you later switch to ddp or some other mode, this will still be called
    so that you don't have to change your code.</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># pseudocode
sub_batches = split_batches_for_dp(batch)
batch_parts_outputs = [validation_step(sub_batch) for sub_batch in sub_batches]
validation_step_end(batch_parts_outputs)
</code></pre></div>
<p>Args:
    batch_parts_outputs: What you return in :meth:<code>validation_step</code>
        for each batch part.</p>
<p>Return:
    None or anything</p>
<p>.. code-block:: python</p>
<div class="highlight"><pre><span></span><code># WITHOUT validation_step_end
# if used in DP or DDP2, this batch is 1/num_gpus large
def validation_step(self, batch, batch_idx):
    # batch is 1/num_gpus big
    x, y = batch

    out = self.encoder(x)
    loss = self.softmax(out)
    loss = nce_loss(loss)
    self.log(&quot;val_loss&quot;, loss)

# --------------
# with validation_step_end to do softmax over the full batch
def validation_step(self, batch, batch_idx):
    # batch is 1/num_gpus big
    x, y = batch

    out = self(x)
    return out

def validation_step_end(self, val_step_outputs):
    for out in val_step_outputs:
        ...
</code></pre></div>
<p>See Also:
    See the :ref:<code>advanced/multi_gpu:Multi-GPU training</code> guide for more details.</p>
<h4 id="xpu_1">xpu</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">xpu</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">:</span> <span class="o">~</span><span class="n">T</span><span class="p">,</span>
    <span class="n">device</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="o">~</span><span class="n">T</span>
</code></pre></div>
<p>Moves all model parameters and buffers to the XPU.</p>
<p>This also makes associated parameters and buffers different objects. So
it should be called before constructing optimizer if the module will
live on XPU while being optimized.</p>
<p>.. note::
    This method modifies the module in-place.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>device</td>
<td>int</td>
<td>if specified, all parameters will be</td>
<td></td>
</tr>
<tr>
<td>copied to that device</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>Returns:</strong></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Module</td>
<td>self</td>
</tr>
</tbody>
</table>
<h4 id="zero_grad_1">zero_grad</h4>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">zero_grad</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">set_to_none</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span>
</code></pre></div>
<p>Sets gradients of all model parameters to zero. See similar function</p>
<p>under :class:<code>torch.optim.Optimizer</code> for more context.</p>
<p><strong>Parameters:</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
<th>Description</th>
<th>Default</th>
</tr>
</thead>
<tbody>
<tr>
<td>set_to_none</td>
<td>bool</td>
<td>instead of setting to zero, set the grads to None.</td>
<td></td>
</tr>
<tr>
<td>See :meth:<code>torch.optim.Optimizer.zero_grad</code> for details.</td>
<td>None</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../" title="Index" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Index
              </span>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Powered by
        <a href="http://timothycrosley.github.io/portray">portray.</a>
        You too can
        <a href="http://timothycrosley.github.io/portray">
          portray</a>
        your Python project well using automatic documentation.
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../../../../assets/javascripts/workers/search.f8263e09.min.js", "version": null}</script>
    
    
      <script src="../../../../assets/javascripts/bundle.4fc53ad4.min.js"></script>
      
    
  </body>
</html>